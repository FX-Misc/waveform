<!--

Note that unlike rm's, tac's, and waveforms, cluster plots cannot be toggled off, which makes life a little simpler.


-->


<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="worker-builder.html">
<link rel="import" href="managed-canvas.html">
<link rel="import" href="utils.html">
<link rel="import" href="palettes.html">
<link rel="import" href="bower_components/iron-a11y-keys/iron-a11y-keys.html">

<dom-module id="cluster-plots">

<script is='worker-builder' id="worker" title="cluster-plots" type='javascript/worker'>
"use strict";


var palette_flag;

var set_palettes = function(arrays){
    palette_flag = new Uint32Array(arrays.flag.buffer);
}

var n_spikes;
var chan_is_ok;
var amps;
var plot_names;
var timer = 0;

var pkey_generation = 0;
var pkey_to_array = new Map();
var pkey_to_desired_options = new Map();
var pkeys_pending_render = [];

var n_c = 4; // TODO: probably shouldn't hard code this here..see parsed-data
var s = 256; // currently there is a 1-to-1 from amp values to pixels

// note that we initalize arrays for the maximum number of plots and never delte them
var plots = (function(){
    let p = [];
    for(let ii=0; ii<n_c*(n_c-1)/2; ii++){
        p.push(new Uint32Array(s*s));
    }
    return p;
})();


var update_pkeys = function(changes, options, arrays){

    if(changes.generation_remove !== pkey_generation){
        changes.remove = [];
        pkey_to_array.clear();
        pkey_to_rendered_options.clear();
        pkeys_pending_render = [];
        console.log("tac-plots worker: key generation mismatch");
    }

    // note we don't both to remove keys from the pending list
    // unless we change key generation, in which case we drop 
    // everything that's pending. This is ensures that when we
    // attempt a render we can be sure that if we do find the
    // array for the given key we know it's for the relevant 
    // generation and that it's still wanted.

    var remove_pkeys = changes.remove || [];
    for(let pkey of remove_pkeys){
        pkey_to_array.delete(pkey);
        pkey_to_desired_options.delete(pkey);
    }

    if(changes.generation_add !== changes.generation_remove){
        pkeys_pending_render = [];
        pkey_generation = changes.generation_add;
    }

    var add_pkeys = changes.add || [];
    for(let pkey of add_pkeys){
        pkey_to_array.set(pkey, arrays[pkey]);
    }

    for(let item of options){
        pkey_to_desired_options.set(item.pkey, item);
        pkeys_pending_render.push(item.pkey);
    }
    touch_timer();
}


var set_amps = function(n_spikes_, chan_is_ok_, arrays){
    n_spikes = n_spikes_;
    chan_is_ok = chan_is_ok_;
    amps = arrays && arrays.data; 
    for(let ii=0; ii<plots.length; ii++){
        plots[ii].fill(0);
    }
    plot_names = [];
    if(chan_is_ok){
        for(let c1=0, p=0; c1<n_c; c1++)if(chan_is_ok[c1]){
            for(let c2=c1+1; c2<n_c; c2++, p++)if(chan_is_ok[c2]){
                let name = (c1+1) + 'Ax' + (c2+1) + 'A';
                plot_names.push(name);
            }
        }        
    }
    touch_timer();
}

var touch_timer = function(){
    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from main thread to interupt
    // between ticks, we can thus cancel work as an when needed.
    if(amps && pkeys_pending_render.length){
        timer = timer || setImmediate(timer_tick);
    } else{
        clearImmediate(timer);
        timer = 0;
    }
}

var timer_tick = function(){
    timer = 0;

    // unlike tac and rm we render all pending groups in a single tick and then *copy*
    // the results back.
    while(pkeys_pending_render.length){
        let pkey = pkeys_pending_render.shift();
        let group_inds = pkey_to_array.get(pkey);
        if(!group_inds){
            continue;
        }
        let pkey_opts = pkey_to_desired_options.get(pkey);
        let color = palette_flag[pkey_opts.group_num];
        for(let c1=0, p=0; c1<n_c; c1++)if(chan_is_ok[c1]){
            for(let c2=c1+1; c2<n_c; c2++, p++)if(chan_is_ok[c2]){
                let im = plots[p];
                for(let ii=0; ii<group_inds.length; ii++){
                    let a1 = amps[group_inds[ii]*n_c +c1];
                    let a2 = amps[group_inds[ii]*n_c +c2];
                    im[(s-1-a1)*s + a2] = color;
                }
            }
        }
    }

    // copy plots into the object to send back to main, labeling each plot
    // with its channel numbers.
    var arrays = {};
    for(let [ii, name] of plot_names.entries()){
        arrays[name] = plots[ii].slice(0);
    }
    exec_main_b('plot_clusters', {
        generation: pkey_generation,
        plots: plot_names
    }, arrays);
}

var get_group_at = function(msg){
    // this is called when the user mousemoves on a canvas
    // it's hardly worth putting this on the worker thread, but maybe on day we
    // will do something more exciting here.

    let point = msg.point;
    let plot = plots[plot_names.indexOf(msg.plot)];
    if(!plot){
        return;
    }
    var r = 8; // square ball radius, i.e. width is 2w+1
    var counts = new Uint32Array(256);
    for(let ii=Math.max(0, point[0]-r); ii< Math.min(s, point[0]+r+1); ii++){
        for(let jj=Math.max(0, point[1]-r); jj< Math.min(s, point[1]+r+1); jj++){
            // TODO: accumulate counts at that point
        }
    }
    exec_main('got_group_at', {
        generation: pkey_generation,
        point: point, // provide the details back to main so it can decide whether or not to use the result
        plot: msg.plot,
        group_num: 3
    })
}

</script>


<style>
.sticker{
display: inline-block;
line-height: 14px;
width: 20px;
height: 17px;
border: 1px solid #000;
text-align: center;
font-size: 10px;
padding-top: 3px;
margin: 1px;
cursor: pointer;
}
.sticker_list{
line-height: 19px;
display: inline;
font-size: 0px;
}
.braket{
line-height: 19px;
font-size: 24px;
vertical-align: top;
}
:host{
--paper-tooltip-opacity: 0.96;
padding-left: 2px;
padding-right: 2px;
display: flex;
flex-direction: column;
height: 100%;
font-size: 0px;
}
::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
.bottom{
flex: 2;
overflow-y: scroll;
text-align: center;
}
.active_stickers{
float: left;
display: inline-block;
}
.others{
text-align: right;
display: block;
}
.new_group{
background: #ffffe0;
}
.plot{
display: inline-block;
position: relative;
border: 1px solid #000;
padding: 1px;
margin-right: 2px;
margin-bottom: 2px;
}
.x_axis_label{
position: absolute;
display: inline-block;
bottom: 2px;
right: 2px;
font-size: 10px;
}
.y_axis_label{
position: absolute;
display: inline-block;
left: 2px;
top: 2px;
font-size: 10px;
}
</style>

<template>
    <iron-a11y-keys keys="enter+only" on-keys-pressed="_new_dest"  target="[[keyboard_target]]"></iron-a11y-keys>
    <!-- TODO: replace the random unicode chars with plus and minus -->
    <iron-a11y-keys keys="»+only" on-keys-pressed="_inc_size"  target="[[keyboard_target]]"></iron-a11y-keys>
    <iron-a11y-keys keys="½+only" on-keys-pressed="_dec_size"  target="[[keyboard_target]]"></iron-a11y-keys>

    <div class="top">
        <div class="active_stickers">
            <div class="sticker_list">
                <div class="sticker" style$="{{_sticker_style(painter_state.dest, active_group_a)}}" 
                        on-mouseenter="_mouseenter_sticker_dest" on-mouseleave="_mouseleave_sticker">
                    [[painter_state.dest]] <paper-tooltip position="below">destination group [e]</paper-tooltip>
                </div>
            </div>
            <span class="braket">&#8592;</span>
            <div class="sticker_list"><span class="braket">{</span>
                <template is="dom-repeat" items="[[painter_state.srcs]]">
                   <div class="sticker" style$="{{_sticker_style(item, active_group_a)}}"
                         on-mouseup="_sticker_click" on-mouseenter="_mouseenter_sticker" on-mouseleave="_mouseleave_sticker">[[item]]</div>
                </template>
                <span class="braket">}</span>
                <paper-tooltip>source groups [e]</paper-tooltip>
            </div>
        </div>
        <div class="sticker_list others">
            <div class="sticker new_group" on-tap="_new_dest">&#10133;
                <paper-tooltip>new destination group [Enter]</paper-tooltip>
            </div>
            <template is="dom-repeat" items="[[other_groups]]">
               <div class="sticker" style$="{{_sticker_style(item, active_group_a)}}"
                    on-mouseup="_sticker_click" on-mouseenter="_mouseenter_sticker" on-mouseleave="_mouseleave_sticker">[[item]]</div>
            </template>
        </div>
    </div>

    <div class="bottom">
        <template is="dom-repeat" items="[[cluster_plots]]">
            <div class="plot" style$="{{_show(item.is_used)}}">
               <managed-canvas canv_id="[[item.ckey]]" fix_height="[[canvas_size]]" 
                        on-canvas-mousemove="_mousemove_canvas" on-mouseleave="_mouseleave_canvas"></managed-canvas>
               <div class="x_axis_label">[[item.x_axis]]</div>
               <div class="y_axis_label">[[item.y_axis]]</div>
            </div>
        </template>
    </div>

</template>
<script>
    "use strict";
    Polymer({
        is:'cluster-plots',
        properties: {
            canvas_size: {
                type: Number,
                notify: true,
                value: 128
            },
            amplitudes: {
                type: Object,
                notify: true,
                value: function(){return {};}
            },
            cluster_plots: {
                type: Array,
                notify: true,
                value: function(){return [];}
            },
            groups: {
                type: Array,
                notify: true,
                value: function(){return [];},
                observer: '_groups_set'
            },
            painter_state: {
                type: Object,
                notify: true,
                value: function(){return {
                    srcs: [0],
                    dest: 0
                }}
            },
            other_groups:{
                type: Array,
                notify: true,
                value: function(){return [];},
                readOnly: true // TODO: this is really a computed-property, but I couldn't get it to work with .splices
                                // instead we use observers
            },
            keyboard_target: {
                type: Object,
                value: function(){return document.querySelector('body');}
            },
            want_amplitudes: {
                type: Array,
                notify: true,
                observer: '_want_amplitudes_set'
            },
            active_group_a:{
                type: Object,
                value: null,
                notify: true
            }
        }, observers: [
            '_groups_spliced(groups.splices)',
            '_compute_unused_groups(painter_state.*)',
            '_amplitudes_modified(amplitudes)'
        ], created: function(){
            var worker_builder = Polymer.DomModule.import('cluster-plots','#worker');
            this._worker = worker_builder.create_for(this);
            this._worker.exec_b('set_palettes', {flag: Palettes.flag.slice(0)});
            this._pkey_generation = 0;
        }, ready: function(){
            let n_c = 4; // TODO: get this from parsed-data
            let s = 256; // TODO: this too, and maybe alow scaling
            let cm = Utils.canvas_manager;
            let plots = [];
            for(let ii=0; ii<n_c*(n_c-1)/2; ii++){
                plots.push({
                    ckey: cm.store_from_dims([s,s]),
                    is_used: false
                });
            }
            this.set('cluster_plots', plots);
            // TODO: we might want to tie the plots to the cut for ease of grabbing
        }, _want_amplitudes_set: function(){
            this.push('want_amplitudes', 'cluster-plots');
        }, _amplitudes_modified: function(){
            if(this.amplitudes){
                var arr = Utils.typed_array_manager.get_array_clone(this.amplitudes.amps);
                this._worker.exec_b('set_amps', this.amplitudes.n, this.amplitudes.chan_is_ok, 
                                    {data: arr});
            } else {
                if(!this._worker) return;
                this._worker.exec('set_amps', {});
            }
        }, _groups_set: function(new_val, old_val){
            this._compute_unused_groups();
            this._groups_collection = Array.isArray(new_val) && Polymer.Collection.get(new_val);
            this._update_okeys(old_val || [], new_val || [], this._pkey_generation, ++this._pkey_generation); // added keys are for a new generation
        }, _groups_spliced: function(splices){
            this._compute_unused_groups();
            let parsed = Utils.parse_splices(splices);
            this._update_okeys(parsed.removed, parsed.added, this._pkey_generation, this._pkey_generation);
        }, _update_okeys: function(okeys_to_remove, okeys_to_add, generation_remove, generation_add){
            var am = Utils.typed_array_manager;
            var cm = Utils.canvas_manager;

            var added_arrays = {};
            var pkeys_to_add = []; 
            var options = [];
            // get clones of new arrays to send to worker
            for(let okey of okeys_to_add){
                if(!okey) continue;
                pkeys_to_add.push(okey._pkey);
                added_arrays[okey._pkey] = am.get_array_clone(okey.akey);
                options.push({
                    pkey: okey._pkey,
                    group_num: okey.group_num
                });
            }

            var pkeys_to_remove = [];
            for(let okey of okeys_to_remove){
                if(!okey) continue;
                pkeys_to_remove.push(okey._pkey);
            }

            // inform worker of the new/deleted arrays
            this._worker.exec_b('update_pkeys', {
                add: pkeys_to_add,
                remove: pkeys_to_remove,
                generation_remove: generation_remove,
                generation_add: generation_add
            }, options, added_arrays);

        }, _sticker_style: function(group_num, active_group_a){
            return "background-color:" + Palettes.flag_css[group_num] + ";color:" + Palettes.flag_css_text[group_num] + ";" +
                    (active_group_a && active_group_a.group_num===group_num ? "box-shadow:0px 0px 5px 3px #fc0;" : "");
        }, _compute_unused_groups: function(){
            if(!this.groups){
                this._setOther_groups([]);
                return [];
            }
            let others = [];
            for(let okey of this.groups)if(okey){
                if(this.painter_state.srcs.indexOf(okey.group_num) === -1 &&
                    this.painter_state.dest !== okey.group_num){
                    others.push(okey.group_num)
                }
            }
            this._setOther_groups(others);
        }, _new_dest: function(){
            // finds first unused number, ignoring zero
            for(let [ii, gg] of this.groups.entries()){
                if(!gg && ii>0){
                    this.set('painter_state.dest', ii);
                }
            }
            this.set('painter_state.dest', this.groups.length);
        }, _sticker_click: function(e){
            let num = e.model.item;
            let index_in_src = this.painter_state.srcs.indexOf(num);
            if(e.button === 0){
                // left button, select as source
                this.set('painter_state.dest', num);
                if(index_in_src >=0){
                    this.splice('painter_state.srcs', index_in_src, 1);
                }
            } else {
                // not left button, select as dest, 
                // splice in/out if shift down, otherwise clear array and set to just num
                if(e.shiftKey){
                    if(index_in_src > -1){
                        this.splice('painter_state.srcs', index_in_src, 1);
                    } else {
                        this.push('painter_state.srcs', num);
                    }
                }else{
                    this.splice('painter_state.srcs', 0, this.painter_state.srcs.length, num);
                }
            }
        }, plot_clusters: function(msg, arrays){
            if(msg.generation !== this._pkey_generation){
                return; // pft, get with the times
            }
            let cm = Utils.canvas_manager;
            for(let [ii,label] of msg.plots.entries()){
                cm.update_from_buffer(this.cluster_plots[ii].ckey, 
                                        arrays[label].buffer);
                let axes = label.split('x');
                this.set('cluster_plots.' + ii + '.x_axis', axes[1]);
                this.set('cluster_plots.' + ii + '.y_axis', axes[0]);
                this.set('cluster_plots.' + ii + '.is_used', true);
            }
            for(let ii=msg.plots.length; ii<this.cluster_plots.length; ii++){
                this.set('cluster_plots.' + ii + '.is_used', false);
            }
        }, _inc_size: function(){
            this.set('canvas_size', Math.min(this.canvas_size+32, 512));
        }, _dec_size: function(){
            this.set('canvas_size', Math.max(this.canvas_size-32, 32));
        }, _show: function(v){
            return v ? '' : 'display: none;';
        }, _mousemove_canvas: function(e){
            let plot_name = e.model.item.y_axis + 'x' + e.model.item.x_axis;
            this._mouse_over_plot = plot_name;
            this._worker.exec('get_group_at', {
                plot: plot_name,
                point: e.detail.canvas_point
            });
        }, _mouseleave_canvas: function(){
            this._mouse_over_plot = null;
            this.set('active_group_a', null);
        }, got_group_at: function(msg){
            if(this._mouse_over_plot !== msg.plot){
                return; // TODO: we could check the msg.point to see if it's still close, but whatever
            }
            this.set('active_group_a', this._okey_from_group_num(msg.group_num));  
        }, _mouseenter_sticker: function(e){
            this.set('active_group_a', this._okey_from_group_num(e.model.item));  
        }, _mouseleave_sticker: function(){
            this.set('active_group_a', null);
        }, _mouseenter_sticker_dest: function(){
            this.set('active_group_a', this._okey_from_group_num(this.painter_state.dest));
        }, _okey_from_group_num: function(num){
            for(let okey of this.groups)if(okey && okey.group_num === num){
                return okey
            }
            return null;
        }
    });
</script>

  
</dom-module>