<!--
CUSTOM ELEMENT: cut-object
BY: DM

This is similar to rm-plots and friends, except that this element is not intended to be a singleton inside 
a tile-wall element.  Instead, there can be many cut-object elements, one for each cut the user has loaded.

The similarity with rm-plots is becuase the "groups" array of the tilewall should be bound
to this element's "groups" property.  Each element of the groups array has an inds value which
is an id for use with typed-array-manager.  This element provides various methods for splicing
and dicing the cut, with each action modifying one or more of the inds values in the groups array.

It also provides a pair of arrays called undo_stack and redo_stack.  They contain deltas, which
(may) include id's for use with typed-array-manager.

The groups array is a list of "boxes", where each box is born with an immutable array of spike indices,
held as .inds on the box.  If the group's inds need to change, we replace the entire box at that location
in the groups list.  This change is emmited as though it were a splice, so interested parties can pick up
on the old box as well as the new box.  Also, sometimes boxes are moved around, i.e. they are spliced out
of one place and into another place.  Interested parties should check whether a box is being removed entirely
or just being moved, before deciding to garbage collect property within that box.  This is possible because
such double splicing are done "atomically", i.e. only one notification is issued.

-->


<link rel="import" href="bower_components/polymer/polymer.html">


<dom-module id="cut-object">

<template></template>


<script>
	"use strict";

    var bin_count = function(group_idx, max_len){
        var ret = new Uint32Array(max_len);
        for(var ii=0; ii<group_idx.length; ii++)
            ret[group_idx[ii]]++; // if group_idx is out of range it seems like no warning/error is raised, at least in chrome 49
        return ret;
    }

    var arg_split = function(groups, group_idx, group_n){
        // sort of like an arg sort followed by a split by value,
        // groups is an array of typed arrays, and group_idx is a
        // single typed_array, with each element specifiying an
        // index into the the groups array.  For each such element,
        // we record in the typed array within groups the index of
        // the element.  group_n is another typed array, which is
        // is of the same length as groups, it shoudld be zero-initialized
        // and we use it counting up the number of entries currently
        // placed into the corresponding typed array within groups.
        // note that each of the typed arrays wihtin groups should have
        // been sized in advance, probably using the bin_count function.
        for(var ii=0; ii<group_idx.length; ii++)
            groups[group_idx[ii]][group_n[group_idx[ii]]++] = ii;
    };

    var mask_split = function(a, mask){
        // splits a into two arrays, one for 0 elements in mask and one for 1 elements
        // note if mask contains other values the result will be nonsense.
        if(mask.length != a.length)
            throw "mask length mismatch";
        var counts = bin_count(mask, 2);
        var a0 = new Uint32Array(counts[0]);
        var a1 = new Uint32Array(counts[1]);
        var p0=0, p1=0;
        for(var ii=0;ii<mask.length; ii++){
            if(mask[ii])
                a1[p1++] = a[ii];
            else
                a0[p0++] = a[ii];
        }
        return [a0, a1];
    };
        
    var merge_sorted = function(a, b){
        // a and b are sorted separetly, we combine them into a sorted new array
        // and create a mask saying which elements were from b
        var res = new Uint32Array(a.length+b.length)
        var mask = new Uint8Array(res.length);
        for(var p_a=0, p_b=0, p_r=0; p_a<a.length; p_a++, p_r++){
            for(;b[p_b]<=a[p_a];p_b++, p_r++){
                res[p_r] = b[p_b];
                mask[p_r] = 1;
            }
            res[p_r] = a[p_a];
        }
        return [res, mask];
    }
    var arange = function(n){
        var ret = new Uint32Array(n);
        for(var ii=0; ii<n; ii++)
            ret[ii] = ii;
        return ret;
    }

    Polymer({
    	is:'cut-object',
    	properties: {
			undo_stack_descriptions: {
				type: Array,
				value: function(){return [];},
                notify: true
    		},
            redo_stack_descriptions: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
			groups: {
    			type: Array,
    			value: function(){return [];},
    			notify: true
    		},
            cut_file: {
                type: String,
                value: "",  //taid
            },
            n_spikes: {
                type: Number,
                value: 0
            }
    	}, 
        observers: [
            'init_cut(cut_file, n_spikes)'
        ],
        swap_groups: function(a, b){
            if(a==b) return;

            // make life easier, fix b>a
            if(a>b){
                var tmp = a;
                a = b;
                b = tmp;
            }
            this._do_swap(a, b);

            this.redo_stack = [];
            this.undo_stack.push({
                action: 'swap',
                a: a,
                b: b
            });
            this.set('redo_stack_descriptions', []);
            this.push('undo_stack_descriptions', 'swap groups ' + a + " and " + b);
        },
        _do_swap: function(a, b){
            // b must be greater than a
            var group_a = this.groups[a];
            var group_b = this.groups[b];

            // TODO: check that this really is the correct way to do it
            // https://github.com/Polymer/polymer/issues/3377
            this.groups.splice(a, 1, group_b);
            this.groups.splice(b, 1, group_a); 
            this.notifySplices('groups',[
                {index: a, removed: [group_a], addedCount: 0, object: this.groups, type:'splice'},
                {index: b-1, removed: [group_b], addedCount: 0, object: this.groups, type:'splice'},
                {index: a, removed: [], addedCount: 1, object: this.groups, type:'splice'},
                {index: b, removed: [], addedCount: 1, object: this.groups, type:'splice'}
            ]); 
        },
        split_group: function(a, mask){
            var m = window.typed_array_manager;

            var new_arrs = mask_split(m.get_array(this.groups[a].inds), mask);
            m.free_array(this.groups[a].inds);
            this.splice('groups', a, 1, {
                inds: m.store_array(new_arrs[0])
            }, {
                inds: m.store_array(new_arrs[1])
            });

            this.redo_stack = [];               
            this.undo_stack.push({
                action: 'split',
                a: a
            });
            this.set('redo_stack_descriptions', []);
            this.push('undo_stack_descriptions', 'split group ' + a + ' in two');
        },
        merge_groups: function(a, b){
            // the higher-numbered group is merged into the lower number
            var m = window.typed_array_manager;

            // make life easier, fix b>a
            if(a>b){
                var tmp = a;
                a = b;
                b = tmp;
            }

            var packed = merge_sorted(m.get_array(this.groups[a].inds), 
                                   m.get_array(this.groups[b].inds))
            var inds = packed[0], mask = packed[1];

            m.free_array(this.groups[a].inds);
            m.free_array(this.groups[b].inds);
            this.splice('groups', b, 1);
            this.splice('groups', a, 1, {
                inds: m.store_array(inds)
            });

            this.redo_stack = [];
            this.undo_stack.push({
                action: 'merge',
                a: a,
                b: b,
                mask: mask
            });
            this.set('redo_stack_descriptions', []);
            this.push('undo_stack_descriptions', 'merge groups ' + a + ' and ' + b);
        },
        undo: function(){
            var delta = this.undo_stack[this.undo_stack.length-1];
            var success = false;

            // note that b will always be greater than a...
            switch(delta.action){
                case "merge":
                var new_arrs = mask_split(m.get_array(this.groups[delta.a].inds), delta.mask);
                m.free_array(this.groups[delta.a].inds);
                this.splice('groups', delta.a, 1, {
                    inds: m.store_array(new_arrs[0])
                });
                this.splice('groups', delta.b, 0, {
                    inds: m.store_array(new_arrs[1])
                });
                delete delta['mask']; // not absolutely neccessary, but we don't need it now
                success = true;
                break;

                case "split":
                // we could have kept the mask originally, but we didn't
                var packed = merge_sorted(m.get_array(this.groups[delta.a].inds), 
                                          m.get_array(this.groups[delta.a+1].inds))
                var inds = packed[0];
                m.free_array(this.groups[delta.a].inds);
                m.free_array(this.groups[delta.a+1].inds);
                this.splice('groups', delta.a, 2, {
                    inds: m.store_array(inds)
                });
                delta.mask = packed[1];
                success = true;
                break;

                case "swap":
                this._do_swap(delta.a, delta.b);
                success = true;
                break;

                default:
                console.log("attempted undo of unknown or invalid delta");
            }

            if(success){
                // note we hadn't yet actually removed the delta from the undo stack
                this.redo_stack.push(this.undo_stack.pop())
                this.push('redo_stack_descriptions', this.pop('undo_stack_descriptions'));
            }

        },
        redo: function(){
            var delta = this.redo_stack[this.redo_stack.length-1];
            if(!delta)
                return;
            var success = false;

            // note that b will always be greater than a...
            switch(delta.action){
                case "merge":
                var packed = merge_sorted(m.get_array(this.groups[delta.a].inds), 
                                          m.get_array(this.groups[delta.b].inds));
                var inds = packed[0];
                m.free_array(this.groups[delta.a].inds);
                m.free_array(this.groups[delta.b].inds);
                this.splice('groups', delta.b, 1);
                this.splice('groups', delta.a, 1, {
                    inds: m.store_array(inds)
                });
                delta.mask = packed[1];
                success = true;
                break;

                case "split":
                // we could have kept the mask originally, but we didn't
                var new_arrs = mask_split(m.get_array(this.groups[delta.a].inds), delta.mask);
                delete delta['mask'];
                m.free_array(this.groups[delta.a].inds);
                this.splice('groups', delta.a, 1, {
                    inds: m.store_array(new_arrs[0])
                }, {
                    inds: m.store_array(new_arrs[1])
                });
                success = true;
                break;

                case "swap":
                this._do_swap(delta.a, delta.b);
                success = true;
                break;

                default:
                console.log("attempted redo of unknown or invalid delta");  
            }
            if(success){
                // note we hadn't yet actually removed the delta from the redo stack
                this.undo_stack.push(this.redo_stack.pop())
                this.push('undo_stack_descriptions', this.pop('redo_stack_descriptions'));
            }
        },
        init_cut: function(cut_file, n_spikes){
            var m = window.typed_array_manager;
            this.set('redo_stack', []);
            if(cut_file){
                cut_file = m.get_array(cut_file);

                // find out how many indices for each group
                var group_n = bin_count(cut_file, 255);

                // zero-initialize an array of the required length for each group
                var groups = [];
                for(var ii=0; ii<group_n.length; ii++)
                    if(group_n[ii]>0)
                        gorups[ii] = new Uint32Array(group_n[ii]);

                // store the indices for each group
                group_n.fill(0); // we repurpose this as a counter during arg_splitting
                arg_split(groups, cut_file, group_n);

                // now we are ready to create the this.groups array of boxes               
                var boxes = [];
                for(var ii=0; ii<groups.length; ii++){
                    if(groups[ii]){
                        boxes.push({
                            inds: m.store_array(groups[ii])
                        });
                    }else{
                        boxes.push({});
                    }
                }
                this.undo_stack = [{
                    action: 'load'
                }];
                this.set('undo_stack_descriptions', ['load from file']);
                this.set('groups', boxes); 

            } else {
                // no cut_file, so just make a zero-group with inds 0:n 
                this.undo_stack =  [{
                    action: 'create'
                }];
                this.set('undo_stack_descriptions', ['create blank cut']);
                this.set('groups', [{
                    inds:  m.store_array(arange(n_spikes))
                }]);
            }
        }
	});
</script>

  
</dom-module>