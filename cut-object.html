<!--
CUSTOM ELEMENT: cut-object
BY: DM

This doesn't have to be a singleton (I hope).

The main property is the "groups" array.  You don't splice and dice it directly, instead you use one of the following:
    init_cut, swap_groups, merge_groups, split_groups, undo, redo

Each element is an object, which contains an .akey property, which is a typed-array manager id for the array of
indices that the object represents.  This id and the indices data never changes during the lifetime of the object.

The rendering modules listen for changes to the groups array and provide/update properties with names
like .spa_rm_canvas, and .dir_rm_canvas.

The groups array is backed by a Polymer.Collection.  This means that each object has a unique key associated
to it, and these keys are valid for the lifetime of the object (well so long as the objected enver leaves
and re-enters the array, which it shoudln't if you only use the special methods listed above).  Note that both
the key and the inds property are unique to the object, but they are distinct - one is used by typed-array-manager
and one is used by Polymer.Collection.

See tac-plots for a reltaively simple example of how the comings and going of keys can be tracked.  Note how
the tac-plots has a private worker and that it uses the keys when "discussing" indices with the worker.  This
makes life very easy, because when the worker returns a rendered result with a key, you can simply lookup the
associated object in the collection, and then provide the lovely new canvas.  tac-plots also maintains a
couple of private maps which use the key as their key (isn't that wonderful?!).  These maps record the last
rendered canvas produced by the woker for the given group, and the settings used to produce that canvas.  
A slight complication is that when the groups array is switched entirely e.g. because a new cut is hooked up to
the tilewall (or maybe beause internally the cut obj decides to assign a new array) the old key's suddenly cease
to be unique.  But at that point we want the plotting code to discard the old ararys completely anyway.  So, we
use the concept of "generation", which is a counter that increments by one each time a new cut array is encountered
to the plotting machinery.  This generation value is passed to the worker with each list of key changes, and then
passed back to the main thread with each delivery of rendered plots.  In other words you  could think of the keys
as being qualified by this generation value, ie. they are really unique_val: "generation.key", but remembering that
we only ever care about one generation at any one time.

A very similar arrangement is used for rm-plots, though things are slightly more complex there.  waves-plots
doesn't have a worker, but it uses a similar system.

-->


<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="utils.html">


<dom-module id="cut-object">

<template></template>


<script>
    "use strict";

(function(){


    var bin_count = function(group_idx, max_len){
        var ret = new Uint32Array(max_len);
        for(var ii=0; ii<group_idx.length; ii++)
            ret[group_idx[ii]]++; // if group_idx is out of range it seems like no warning/error is raised, at least in chrome 49
        return ret;
    }

    var arg_split = function(groups, group_idx, group_n){
        // sort of like an arg sort followed by a split by value,
        // groups is an array of typed arrays, and group_idx is a
        // single typed_array, with each element specifiying an
        // index into the the groups array.  For each such element,
        // we record in the typed array within groups the index of
        // the element.  group_n is another typed array, which is
        // is of the same length as groups, it shoudld be zero-initialized
        // and we use it counting up the number of entries currently
        // placed into the corresponding typed array within groups.
        // note that each of the typed arrays wihtin groups should have
        // been sized in advance, probably using the bin_count function.
        for(var ii=0; ii<group_idx.length; ii++)
            groups[group_idx[ii]][group_n[group_idx[ii]]++] = ii;
    };

    var mask_split = function(a, mask){
        // splits a into two arrays, one for 0 elements in mask and one for 1 elements
        // note if mask contains other values the result will be nonsense.
        if(mask.length != a.length)
            throw "mask length mismatch";
        var counts = bin_count(mask, 2);
        var a0 = new Uint32Array(counts[0]);
        var a1 = new Uint32Array(counts[1]);
        var p0=0, p1=0;
        for(var ii=0;ii<mask.length; ii++){
            if(mask[ii])
                a1[p1++] = a[ii];
            else
                a0[p0++] = a[ii];
        }
        return [a0, a1];
    };
        
    var merge_sorted = function(a, b){
        // a and b are sorted separetly, we combine them into a sorted new array
        // and create a mask saying which elements were from b
        var res = new Uint32Array(a.length+b.length)
        var mask = new Uint8Array(res.length);
        for(var p_a=0, p_b=0, p_r=0; p_a<a.length; p_a++, p_r++){
            for(;b[p_b]<=a[p_a];p_b++, p_r++){
                res[p_r] = b[p_b];
                mask[p_r] = 1;
            }
            res[p_r] = a[p_a];
        }
        return [res, mask];
    }
    var arange = function(n){
        var ret = new Uint32Array(n);
        for(var ii=0; ii<n; ii++)
            ret[ii] = ii;
        return ret;
    }

    var CutStackState = function(that){
        this.is = "stack";
        this.undo_stack_descriptions = that.undo_stack_descriptions;
        this.redo_stack_descriptions = that.redo_stack_descriptions;
        this.groups = that.groups;
        this.undo_stack = that.undo_stack;
        this.redo_stack = that.redo_stack;
        return this;
    }

    CutStackState.prototype.get_blob_url = function(experiment_name){
        // This methods is called by file-organiser when dragging starts

        var am = Utils.typed_array_manager;

        // build the 1d array that gives the group number for each spike...

        // I'm not sure if total n_spikes is already avialble somehwere, but hey...
        var n_spikes = 0;
        for(let gg of this.groups){
            n_spikes += gg && gg.n_spikes;
        }

        var the_cut = new Uint8Array(n_spikes);
        for(let ii=0; ii<this.groups.length; ii++){
            let gg = this.groups[ii];
            if(!gg){
                continue;
            }
            let inds = am.get_array(gg.akey);
            for(let jj=0; jj<inds.length; jj++){
                the_cut[inds[jj]] = ii;
            }
        }

        // and now construct the string
        let str = ['n_clusters: ' + this.groups.length,
                   'n_channels: 4',
                   'n_params: 0',
                   'times_used_in_Vt: 0 0 0 0'];

        for(let ii=0; ii<this.groups.length; ii++){
            str.push(' cluster: ' + ii + ' center: 0 0 0 0 0 0 0 0');
            str.push(' min:   0 0 0 0 0 0 0 0');
            str.push(' max:   0 0 0 0 0 0 0 99');
        }
        str.push('');
        str.push('Exact_cut_for: '+ experiment_name +' spikes: ' + n_spikes);
        str.push('');
        str = str.join('\n') + Array.prototype.join.call(the_cut, ' ');

        var b = new Blob([str], {type: 'text/plain'}); 
        return window.URL.createObjectURL(b);
    }

    Polymer({
        is:'cut-object',
        properties: {
            undo_stack_descriptions: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            redo_stack_descriptions: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            groups: {
                type: Array,
                value: function(){return [];},
                notify: true
            },
            cut_box: {
                type: Object,
                value: function(){return {};},
                notify: true,
                observer: '_use_cut_box'
            }
        },
        _make_box: function(inds){
            return {
                group_num: 1, // TODO: update this properly
                akey: Utils.typed_array_manager.store_array(inds),
                n_spikes: inds.length,
                spa_max: -1,
                dir_rm: "",
                spa_rm: "",
                speed_rm: "",
                tac: "",
                waves: ""
            };
        },
        _use_cut_box: function(){
            var m = Utils.typed_array_manager;

            if (this.cut_box && this.cut_box.is === "file"){
                // construct from file
                let akey = m.get_array(this.cut_box.akey);

                // find out how many indices for each group
                let group_n = bin_count(akey, 255);

                // zero-initialize an array of the required length for each group
                let groups = [];
                for(let ii=0; ii<group_n.length; ii++) if(group_n[ii]>0){
                    groups[ii] = new Uint32Array(group_n[ii]);
                }

                // store the indices for each group
                group_n.fill(0); // we repurpose this as a counter during arg_splitting
                arg_split(groups, akey, group_n);

                // now we are ready to create the this.groups array of boxes               
                let boxes = [];
                for(let gg of groups){
                    if(gg){
                        boxes.push(this._make_box(gg));
                    }else{
                        boxes.push(null);
                    }
                }
                this.undo_stack = [{
                    action: 'load'
                }];

                this.set('groups', boxes); 
                this.set('undo_stack_descriptions', ['load from file']);
                this.set('redo_stack_descriptions', []);
                this.redo_stack = [];

            } else if (this.cut_box && this.cut_box.is === "stack"){
                // reinstate existing cut object
                this.set('groups', this.cut_box.groups);
                this.set('undo_stack_descriptions', this.cut_box.undo_stack_descriptions);
                this.set('redo_stack_descriptions', this.cut_box.redo_stack_descriptions);
                this.undo_stack = this.cut_box.undo_stack;
                this.redo_stack = this.cut_box.redo_stack;

            } else if(this.cut_box && this.cut_box.is === "n"){
                // no cut_file, so just make a zero-group with inds 0:n 
                this.undo_stack = [{
                    action: 'create'
                }];
                this.set('undo_stack_descriptions', ['create blank cut']);
                this.set('redo_stack_descriptions', []);
                this.set('groups', [this._make_box(arange(this.cut_box.n_spikes))]);
                this.undo_stack = [];
                this.redo_stack = [];

            } else {
                // clear current state
                this.set('groups', []);
                this.set('undo_stack_descriptions', []);
                this.set('redo_stack_descriptions', []);
                this.undo_stack = [];
                this.redo_stack = [];

            }
        },
        _fork_if_needed: function(){
            if(!this.cut_box.is_stack){
                // tell the file-organiser to construct a new "cut box" from the preservable state of this element.
                // note that the new "cut box" will be applied to this element as its cut_box, but this will not
                // cause any changes as all the values will be the same.

                // we could hold the reference directly, but it complciates matters when doing bulk updates of trials
                let new_cut = Utils.file_manager.store_file(new CutStackState(this)); 
                this.fire('fork', new_cut);
            }
        }, swap_groups: function(a, b){
            if(a==b) return;
            this._fork_if_needed();

            // make life easier, fix b>a
            if(a>b){
                var tmp = a;
                a = b;
                b = tmp;
            }
            this._do_swap(a, b);

            this.redo_stack.splice(0, this.redo_stack.length); // clear     
            this.undo_stack.push({
                action: 'swap',
                a: a,
                b: b
            });
            this.splice('redo_stack_descriptions', 0, this.redo_stack_descriptions.length); // clear
            this.push('undo_stack_descriptions', 'swap groups ' + a + " and " + b);
        },
        _do_swap: function(a, b){
            // b must be greater than a
            var group_a = this.groups[a];
            var group_b = this.groups[b];

            // TODO: check that this really is the correct way to do it
            // https://github.com/Polymer/polymer/issues/3377
            this.groups.splice(a, 1, group_b);
            this.groups.splice(b, 1, group_a); 
            this.notifySplices('groups',[
                {index: a, removed: [group_a], addedCount: 0, object: this.groups, type:'splice'},
                {index: b-1, removed: [group_b], addedCount: 0, object: this.groups, type:'splice'},
                {index: a, removed: [], addedCount: 1, object: this.groups, type:'splice'},
                {index: b, removed: [], addedCount: 1, object: this.groups, type:'splice'}
            ]); 
        },
        split_group: function(a, mask){
            this._fork_if_needed();
            var m = Utils.typed_array_manager;

            var new_arrs = mask_split(m.get_array(this.groups[a].akey), mask);
            m.free_array(this.groups[a].akey);
            this.splice('groups', a, 1, this._make_box(new_arrs[0]), this._make_box(new_arrs[1]));

            this.redo_stack.splice(0, this.redo_stack.length); // clear                   
            this.undo_stack.push({
                action: 'split',
                a: a
            });

            this.splice('redo_stack_descriptions', 0, this.redo_stack_descriptions.length); // clear
            this.push('undo_stack_descriptions', 'split group ' + a + ' in two');
        },
        merge_groups: function(a, b){
            // the higher-numbered group is merged into the lower number
            this._fork_if_needed();
            var m = Utils.typed_array_manager;

            // make life easier, fix b>a
            if(a>b){
                var tmp = a;
                a = b;
                b = tmp;
            }

            var packed = merge_sorted(m.get_array(this.groups[a].akey), 
                                   m.get_array(this.groups[b].akey))
            var inds = packed[0], mask = packed[1];

            m.free_array(this.groups[a].akey);
            m.free_array(this.groups[b].akey);
            this.splice('groups', b, 1);
            this.splice('groups', a, 1, this._make_box(inds));

            this.redo_stack.splice(0, this.redo_stack.length); // clear
            this.undo_stack.push({
                action: 'merge',
                a: a,
                b: b,
                mask: mask
            });
            this.splice('redo_stack_descriptions', 0, this.redo_stack_descriptions.length); // clear
            this.push('undo_stack_descriptions', 'merge groups ' + a + ' and ' + b);
        },
        undo: function(){
            var m = Utils.typed_array_manager;
            var delta = this.undo_stack[this.undo_stack.length-1];
            var success = false;

            // note that b will always be greater than a...
            switch(delta.action){
                case "merge":
                var new_arrs = mask_split(m.get_array(this.groups[delta.a].akey), delta.mask);
                m.free_array(this.groups[delta.a].akey);
                this.splice('groups', delta.a, 1, this._make_box(new_arrs[0]));
                this.splice('groups', delta.b, 0, this._make_box(new_arrs[1]));
                delete delta['mask']; // not absolutely neccessary, but we don't need it now
                success = true;
                break;

                case "split":
                // we could have kept the mask originally, but we didn't
                var packed = merge_sorted(m.get_array(this.groups[delta.a].akey), 
                                          m.get_array(this.groups[delta.a+1].akey))
                var inds = packed[0];
                m.free_array(this.groups[delta.a].akey);
                m.free_array(this.groups[delta.a+1].akey);
                this.splice('groups', delta.a, 2, this._make_box(inds));
                delta.mask = packed[1];
                success = true;
                break;

                case "swap":
                this._do_swap(delta.a, delta.b);
                success = true;
                break;

                default:
                console.log("attempted undo of unknown or invalid delta");
            }

            if(success){
                // note we hadn't yet actually removed the delta from the undo stack
                this.redo_stack.push(this.undo_stack.pop())
                this.push('redo_stack_descriptions', this.pop('undo_stack_descriptions'));
            }

        },
        redo: function(){
            var m = Utils.typed_array_manager;
            var delta = this.redo_stack[this.redo_stack.length-1];
            if(!delta)
                return;
            var success = false;

            // note that b will always be greater than a...
            switch(delta.action){
                case "merge":
                var packed = merge_sorted(m.get_array(this.groups[delta.a].akey), 
                                          m.get_array(this.groups[delta.b].akey));
                var inds = packed[0];
                m.free_array(this.groups[delta.a].akey);
                m.free_array(this.groups[delta.b].akey);
                this.splice('groups', delta.b, 1);
                this.splice('groups', delta.a, 1, this._make_box(inds));
                delta.mask = packed[1];
                success = true;
                break;

                case "split":
                // we could have kept the mask originally, but we didn't
                var new_arrs = mask_split(m.get_array(this.groups[delta.a].akey), delta.mask);
                delete delta['mask'];
                m.free_array(this.groups[delta.a].akey);
                this.splice('groups', delta.a, 1, this._make_box(new_arrs[0]), this._make_box(new_arrs[1]));
                success = true;
                break;

                case "swap":
                this._do_swap(delta.a, delta.b);
                success = true;
                break;

                default:
                console.log("attempted redo of unknown or invalid delta");  
            }
            if(success){
                // note we hadn't yet actually removed the delta from the redo stack
                this.undo_stack.push(this.redo_stack.pop())
                this.push('undo_stack_descriptions', this.pop('redo_stack_descriptions'));
            }
        }
    });

})();
</script>

  
</dom-module>