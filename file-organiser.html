<!--
CUSTOM ELEMENT: file-organiser
by: DM
-->

<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/iron-list/iron-list.html">
<link rel="import" href="utils.html">
<link rel="import" href="worker-builder.html">


<dom-module id="file-organiser">

<script is='worker-builder' id="cut_reader" title="cut-base-reader" type='javascript/worker'>
"use strict";

var get_base_for_cuts = function(files){
	// we don't bother with anything complicated here in terms of ticks/caching etc.
	// just iterate over every single file we recieve and read its experiment name
    var reader = new FileReaderSync();
    var batch_bytes = 10*1024;
    var regex_exact_cut = /Exact_cut_for: ((?:[\s\S](?! spikes:))*[\s\S])\s*spikes: ([0-9]*)/;
    var results = [];
	for (let ii=0; ii<files.length; ii++){
		let ff = files[ii];
		let header = "";
		for(let p=0; p<ff.size; p+= batch_bytes){
			// should only take one iteration
			header += reader.readAsBinaryString(ff.slice(p, p+batch_bytes));
			let match = regex_exact_cut.exec(header);
			if(match){
				results.push({
					file: ff,
					base: match[1]
				});
				break;
			}
		}
		// if something is wrong we end up reading the whole file and fail to find a match
	}
	exec_main('got_base_for_cuts', results);
}

</script>


<style>
::-webkit-scrollbar {
width: 10px;
height: 10px;
}
::-webkit-scrollbar-button {
width: 0;
height: 0;
display: none;
}
::-webkit-scrollbar-thumb {
background-color: rgba(0,0,0,0.2);
-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
}
.trial{
background: #f5f5f5;
padding: 5px;
border: 1px solid #ccc;
cursor: pointer;
display: block;
margin: 2px;
width: initial !important;
}
.trial_top{
margin-bottom: 4px;
}
.trial_bottom{

}
.trial_title{
font-weight: bold;
display: inline-block;
margin-right: 4px;
font-size: 12px;
}
.trial_set,
.trial_pos,
.trial_tet,
.trial_cut{
display: inline-block;
border: 1px #000 solid;
padding: 1px 2px 1px 2px;
margin-left: 1px;
background: #ddd;
cursor: default;
font-size: 10px;
}
.trial_tet_block{
display: inline-block;
border-left: 2px solid #000;
margin-right: 4px;
margin-bottom: 2px;
}
.trial_pos,
.trial_set{
background: #ddb550;
border-color: #552510;
color: #552510;
border-width: 2px;
}
.trial_cut{
background: #fbb;
border-color: #500;
color: #500;
}
.trial_cut.obj{
background: #bbF;
border-color: #005;
color: #005;
}
iron-list{
flex: 2;
overflow-x: hidden !important;
}
:host{
display: flex;
flex-direction: column;
font-size: 0px;
};
.tet_button{
background: #f5f5f5;
text-align: center;
padding: 5px 10px 5px 10px;
margin: 2px;
display: inline-block;
border: 1px solid #ccc;
cursor: pointer;
font-size: 12px;
}
.tet_switcher_title{
font-size: 12px;
display: inline-block;
margin-left: 4px;
}
</style>
<template>
  <div class="tet_switcher" style$="[[_scroll_shadow(scrolled_down)]]">
  	<div class="tet_switcher_title">tetrode:</div>
  	<template is="dom-repeat" items="[[available_tets]]">
  		<div class="tet_button">[[item]]</div>
  	</template>
  </div>
  <iron-list items="[[trials]]" as="trial" id="trial_list">
    <template><div><div class='trial'>
	    <div class='trial_top' on-mouseenter="_make_trial_captions">
		    <div class='trial_title'>trial '[[trial.name]]'</div>
		    <div class='trial_set' style$='display:[[_show(trial.set)]];' title$='[[trial.set_caption]]'>~.set</div>
		    <div class='trial_pos' style$='display:[[_show(trial.pos)]];' title$='[[trial.pos_caption]]'>~.pos</div>
		</div>
		<div class='trial_bottom'>
			<template is='dom-repeat' items="[[trial.tets]]" as="tet_block"> 
				<div class='trial_tet_block' on-mouseenter="_make_tet_captions">
					<div class='trial_tet' style$='display:[[_show(tet_block.tet)]];' title$='[[tet_block.tet_caption]]'>~.[[tet_block.tet_num]]</div>
					<template is='dom-repeat' items="[[tet_block.cuts]]" as="cut">
						<div class$='trial_cut [[cut.cut_type]]' title$='[[cut.caption]]'>[[cut.short_name]]</div>
					</template>
				</div>
			</template>
		</div>
    </div></div></template>
  </iron-list>
</template>

<script>
	
Polymer({
	is: 'file-organiser',
	properties: {
		no_files: {
			type: Boolean,
			value: true,
			notify: true,
			readOnly: true
		},
		is_dragging_out: {
			type: Boolean,
			value: false,
			notify: true,
			readOnly: true
		},
		is_dragging_in: {
			type: Boolean,
			value: false,
			notify: true,
			readOnly: true
		},
		scrolled_down: {
			type: Boolean,
			value: false,
			notify: true,
			readOnly: true
		},
		available_tets: {
			type: Array,
			value: function(){return [];},
			notify: true,
			readOnly: true
		},
		trials: {
			type: Array,
			value: function(){ return [];}
		}
	}, created: function(){
		this._time_formatter = new Intl.DateTimeFormat({},{hour: "numeric", minute: "numeric"});
		this._date_formatter = new Intl.DateTimeFormat({}, {month:"short", day:"numeric", year: "numeric"});
		this._byte_formatter = new Intl.NumberFormat({}, {maximumFractionDigits: 0});
		this._file_from_fkey = [undefined]; // fkeys are simple numerical indices, >0
		this._trial_from_base = new Map();
	    document.addEventListener("dragover", this._dragover.bind(this));
	    document.addEventListener("drop", this._drop.bind(this));
    }, attached: function(){
    	var self = this;
    	this.$.trial_list.addEventListener('scroll', function(){
	    	self._setScrolled_down(this.scrollTop > 0);
	    });
    },_dragover: function(e){
		if(this.is_dragging_out) return;
		
        e.stopPropagation();
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
        this._setIs_dragging_in(true);
      	// TODO: use all the drag events correctly
    	// drag over is fired every few ms, show dragging notification for at least 500ms 
        clearTimeout(this._drag_end_timer)
        this._drag_end_timer = setTimeout(this._cancel_drag.bind(this),500); 

    }, _drop: function(e){
	  	e.stopPropagation();
        e.preventDefault();
        this._setNo_files(false); // TODO: wait till we've actually processed the files
        this._cancel_drag();
        var files = e.dataTransfer.files; // FileList object.
           
    	var regex_file_ext = /\.([0-9a-z]+)$/i;
    	var ignore_exts = new Set(['eeg', 'egf', 'eeg2', 'egf2', 'inp']); 
    	var files_for_base = new Map();
    	var pending_cut_files = [];

        // get lists of pos,set,tet files for each trial, and a single list of all cut files
        // and also store a reference to all those files by fkey
        for(let ii=0; ii<files.length; ii++){
        	let ff = files[ii];
        	let fname = ff.name;
            let ext = regex_file_ext.exec(fname);
			let base; // we will leave/set as undefined if we don't care about the file
			
			if (ext){
			    ext = ext[1].toLowerCase();
				base = fname.slice(0, fname.length-ext.length-1);

				if(ext === "pos" || ext === "set"){
					// good
				} else if(ignore_exts.has(ext)){
					continue;
				} else if(ext === "cut"){
					pending_cut_files.push(files[ii]);
					base = undefined;
				} else if(!isNaN(parseInt(ext))){
					if(base.slice(-4) === ".clu"){
						if(base.slice(-9) === ".temp.clu"){
							continue;
						} else {
							pending_cut_files.push(files[ii]);
							base = undefined;
						}
					} else if(base.slice(-4) === ".fet" ||
							  base.slice(-4) === ".klg" ){
						continue;
					} // else a tet file
				} else {
					continue; // entirely unknown file type
				}

				// store permanent reference to the file
	        	let fkey = this._file_from_fkey.length;
				this._file_from_fkey.push(files[ii]);
				if(base){
					// unless it was a cut, we now know the base ok...
					let trial_files = files_for_base[base] = files_for_base[base] || new Set();
					trial_files.add(fkey);
				}
			}
		}
		
		// try and assign cuts based on available trial bases (from this and previous drops)
		var all_bases = new Set();
		for(let b in this._trial_from_base)
			all_bases.add(b);
		for(let b in files_for_base)
			all_bases.add(b);
		var re = Utils.regex_from_list(Array.from(all_bases));
		var difficult_cut_files = [];
		if(re){
			while(pending_cut_files.length){
				let ff = pending_cut_files.pop();
				match = re.exec(ff.name);
				if(match){
					match = match[0];
					files_for_base[match] = files_for_base[match] || new Set();
					let fkey = this._file_from_fkey.length;
					this._file_from_fkey.push(ff);
					files_for_base[match].add(fkey);
				} else {
					let ext = regex_file_ext.exec(ff.name)[1].toLowerCase();
					if(ext === "cut"){
						difficult_cut_files.push(ff);
					} // if it's a clu file we're stuffed
				}
			}		
		} else {
			difficult_cut_files = pending_cut_files;
		}

		if(difficult_cut_files.length){
			this._worker = this._worker || Polymer.DomModule.import('file-organiser', '#cut_reader').create_for(this);
			this._worker.exec('get_base_for_cuts', difficult_cut_files);
		}

		var trials = this.trials; // we are going to make a lot of changes to this, so we do a hack-ed notify-all at the end
		var available_tets = new Set(this.available_tets); // we want this as a set for use bellow...
		for(let base in files_for_base){
			let trial_files = files_for_base[base];
			let trial = this._trial_from_base[base];
			if(!trial){
				trial = {
					name: base,
					tets: []
				};
				this._trial_from_base[base] = trial;
				trials.push(trial);
			}
			for(let fkey of trial_files){
				let ff = this._file_from_fkey[fkey];
	            let ext = regex_file_ext.exec(ff.name)[1].toLowerCase();
	            if(ext === "set"){
	            	trial.set = fkey;
	            } else if(ext === "pos"){
	            	trial.pos = fkey;
	            } else if (ext === "cut"){
	            	// note we sort and de-dupe cuts at the end of the trial_files loop (TODO: that)
	            	let num = ff.name.match(this._regex_cut_tet_num);
					if(num){
						num = parseInt(num[1]);
						tet_obj = this._get_tet_obj(trial, num);
						available_tets.add(num);
						tet_obj.cuts.push({
							cut: fkey,
							cut_type: 'cut',
							short_name: ff.name.replace(base, '~')
						});
					} 
	            } else {
	            	let tet_num = parseInt(ext);
	            	let tet_obj = this._get_tet_obj(trial, tet_num);
	            	available_tets.add(tet_num);
	            	if(ff.name.slice(-ext.length-".clu".length -1, -ext.length-1) === ".clu"){
	            		// clu file
	            		tet_obj.cuts.push({
							cut: fkey,
							cut_type: 'clu',
							short_name: ff.name.replace(base, '~')
						});
	            	} else {
	            		// tet file
		            	tet_obj.tet = fkey;
	            	}
	            }
			}
			this._sort_trial_innards(trial); // sort tets and cuts
		}


		trials.sort(function(a,b){
			return a.name > b.name;
		})
		available_tets = Array.from(available_tets);
		available_tets.sort(this._numeric_sort);
		this._setAvailable_tets(available_tets);
		this._reassign_trials_denovo();	// notify absolutely everything !!! 
	}, _sort_trial_innards: function(trial){
		// sort tets for the trial
		trial.tets = trial.tets.sort(function(a,b){
			return a.tet_num > b.tet_num ? 1 : -1;
		})

		// de-dupe cuts and sort by name and last-modified date
		// TODO: deal with cut obj kind
		for(let ii=0; ii<trial.tets.length; ii++){
			let tet_obj = trial.tets[ii];
			if(tet_obj.cuts.length > 1){
				let name_and_time_strs = new Set()
				for(let jj=0; jj<tet_obj.cuts.length; jj++)	{
					if(!tet_obj.cuts[jj].date_name_str){
						let ff = this._file_from_fkey[tet_obj.cuts[jj].cut];
						let d = tet_obj.cuts[jj].date = ff.lastModified;
						tet_obj.cuts[jj].date_name_str = d + " " + ff.name;
					}
					if(name_and_time_strs.has(tet_obj.cuts[jj].date_name_str)){
						tet_obj.cuts.splice(jj--, 1); // i.e. remove this cut
					} else {
						name_and_time_strs.add(tet_obj.cuts[jj].date_name_str);
					}
				}
				tet_obj.cuts.sort(function(a,b){
					return b.date - a.date;
				});
			}
		}
	}, _get_tet_obj: function(trial, tet_num){
		// adds it to trial.tets if it doesn't exist
    	for(tt=0; tt<trial.tets.length; tt++){
    		if(trial.tets[tt].tet_num === tet_num){
    			return trial.tets[tt];
    		}
    	}
    	var obj = {
			tet_num: tet_num,
			cuts: []
		};
		trial.tets.push(obj);
		return obj;

	}, _cancel_drag: function(){
		clearTimeout(this._drag_end_timer);
		this._drag_end_timer = 0;
		this._setIs_dragging_in(false);
	}, _show: function(v){
		return v ? '' : 'none';
	}, _scroll_shadow: function(v){
		return v ? 'box-shadow: 0px 3px 4px 0px #bbb;z-index: 1;' : '';
    }, _make_trial_captions: function(e){
    	var model = e.model;
    	if(!model.trial.set_caption && model.trial.set){
    		model.set('trial.set_caption', this._caption_from_file(this._file_from_fkey[model.trial.set]));
    	}
    	if(!model.trial.pos_caption && model.trial.pos){
    		model.set('trial.pos_caption', this._caption_from_file(this._file_from_fkey[model.trial.pos]));
    	}
    }, _make_tet_captions: function(e){
    	var model = e.model;
    	if(!model.tet_block.tet_caption && model.tet_block.tet){
	    	model.set('tet_block.tet_caption', this._caption_from_file(this._file_from_fkey[model.tet_block.tet]));	
    	}
    	for(let ii=0; ii<model.tet_block.cuts.length; ii++){
    		if(!model.tet_block.cuts[ii].caption){
		    	model.set('tet_block.cuts.' + ii + '.caption', this._caption_from_file(this._file_from_fkey[model.tet_block.cuts[ii].cut]));			
    		}
    	}
    }, _caption_from_file: function(file){
    	 // Note that reading file.lastModified is slow, so we only call this func when needed
    	 var d = new Date(file.lastModified);
    	 return file.name + " (" + this._byte_formatter.format(file.size/1204) + 
    	 		"KB)\nmodified at " + this._time_formatter.format(d)
    	 		 + " on " + this._date_formatter.format(d);
    }, _numeric_sort: function(a,b){
    	return a-b; 
    }, _reassign_trials_denovo: function(){
		// TODO: see https://github.com/Polymer/polymer/issues/2279
		this.set('trials', JSON.parse(JSON.stringify(this.trials)));
		this._trial_from_base.clear();
		for(let ii=0; ii<this.trials.length; ii++){
			this._trial_from_base[this.trials[ii].name] = this.trials[ii];
		}
    }, got_base_for_cuts: function(results){
    	// TODO: there is a lot of copy-paste from main drop function, should fix that really.
    	var trials = this.trials;
    	var available_tets = new Set(this.available_tets); // we want this as a set for use below...
    	var modified_trials = new Set(); // we will sort the innards of these trials at the end
    	for(let ii=0; ii<results.length; ii++){
    		let base = results[ii].base;
    		let ff = results[ii].file;
    		let trial = this._trial_from_base[base];
    		if(!trial){
    			trial = {
					name: base,
					tets: []
				};
				trials.push(trial);
    		}
        	let num = ff.name.match(this._regex_cut_tet_num);
			if(num){
				num = parseInt(num[1]);
				tet_obj = this._get_tet_obj(trial, num);
				available_tets.add(num);
				let fkey = this._file_from_fkey.length;
				this._file_from_fkey.push(ff);
				tet_obj.cuts.push({
					cut: fkey,
					cut_type: 'cut',
					short_name: ff.name.replace(base, '~')
				});
			} 
	    	modified_trials.add(trial);
    	}
    	for(let trial of modified_trials){
    		this._sort_trial_innards(trial);
    	}
		trials.sort(function(a,b){
			return a.name > b.name;
		})
		available_tets = Array.from(available_tets);
		available_tets.sort(this._numeric_sort);
		this._setAvailable_tets(available_tets);
    	this._reassign_trials_denovo();
    },
    _regex_cut_tet_num: /(\d*)[a-zA-Z _]*\.cut$/
})

</script>
</dom-module>