<!--
CUSTOM ELEMENT: parsed-data
bY: DM

Files can be refered to by "fkey", which is an integer provided by
file-organiser.

The current selection of files is held in the 'files' proeprty.
When the user jumps somewhere in the file organiser, this 'files' object
is updated.  This module then sends out null-ing notfications for the
data which is no longer valid, but leaves whatever it can i.e. if we change
tet but not trial, or cut but not tet we don't need to invalidate everything.

On the io-worker thread we have a setImmediate "timer", which ensures that all pending messages from main thread
are seen between each file-read operation.  We don't have such a timer on the set/tet/pos/cut threads.

Caching...

Note that this was designed and written with the expectation that MessageChannels could transfer arraybuffers,
just like worker-main thread communication can. However in Chrome (and we only care about Chrome) this turns
out not to be the case.  https://bugs.chromium.org/p/chromium/issues/detail?id=334408.  The workaround in use here
is that rather than send a pre-read buffer from io-worker to tet/set/pos etc. workers, the file (handle) is sent, 
the read takes place on the tet/set/pos etc. worker, and then a reply is immediately sent back to the io-worker,
saying to continue with the next read operation.

Main thread issues requests to io-worker thread, which in turn issues requests to set/cut/tet/pos threads.
There is a buffer cache on tet/pos threads, which is managed by (i.e. add/delete instructions issued by)
the io-worker.  And there is an entierly spearate parsed-data cache on the main thread, the various parts 
of which are managed by the corresponding upstream workers (i.e. cut/set/tet/pos).

Requests begin either when the user switches to a set-pos-tet-cut tuple, some of which may be null, and some of which
may be uncahnged from the previous setting.  Or when the user changes the pos setttings, or changes which parts of the 
tet file it needs (i.e. header, times, amps, gl_data).  The caching scheme alows the main thread to fulfill some
of the request directly from its own cache, sending whatever remains to the io-worker as a single request.
Any types (i.e. 'set', 'tet' etc.) in the request sent to the io-worker will overwrite the previous request for
the given file type, with null being used to signify no-file (undefined is treated as though the type were absent).

The io-worker knows exactly which files are already in the cache of the corresponding workers, and can immedaitely
forward those requests.  Anything not in cache will be read off disk in a specific order of type priority (i.e.
tet files should be read off disk first, then pos files...see code for the current logic used).  The workers, 
when they receive requests from the io-thread know whether any of the requested parts is already in the main-thread's
cache, and can avoid re-computing that.  

To seee why this is all helpful, consider an indecisve user trying to load tet file a, then b, then a again, in very 
quick succession.  By the time the user makes the third request, the main thread doesn't yet have the parsed data
in its cahce, so it has to issue a full request to the io-worker.  The io-worker may have ended up loading file-a
due to the first request, or it may never have bothered, instead loading file-b.  In the frist case (where it did
load file-a), when the third request arrives, it knows that the tet worker currently has the buffer in its cache, so
 there's no need to load it again.  (Assuming the io-worker didn't request the buffer to be deleted from the
 tet's cache in the meantime - and if the io-worker had issued this request it would well know that the buffer wasn't in cache.)
 In the second case (where it didn't load file-a initally), the io-worker will now read it off disk and send it to
 the tet-worker to parse (and put in its cache).  Whichever of the two cases happend, the tet-worker will end up
with a request to parse a buffer that it does indeed have access to.  However, if the file-a request made it through twice, then
the tet-worker knows that it already sent data to the main-thread (and hasn't yet requested main thread to delte it
from the cache) thus it knows that in fact main thread already has the data being requested, so there is no need
to do anything.

In summary, it's complciated!  Also, in summary, there is one cache on the main thread with fully-parsed results,
and an entirely separate cache on the pos/tet threads, which contains raw buffers.  In both cases, the cache is
manged by the upstream worker, which in the case of the tet/pos-worker is the io-worker, and in the case of the
main thread is the tet/pos-worker.  Hopefully this arrangement ensures that if something is available in cache
it's never redundantly laoded/computed de novo, and it also ensures that each request recived by tet/set/pos/cut
worker can be processed at the point it is received (ie. without resorting to throwing messages backwards and 
forwards to get data to where it needs to be), and it ensures that no data needs to be copied unneccasrily - it
can all be transfered to its destination using transferable buffers.

...well, there is a contrived scenario in which we don't end up with the optimal result, which is if the tet
worker sends the required parsed data to main thread, after main threada has issued a second request for it,
and then immediately afterwards the io-thread asks to delete the buffer from the tet cache..then the io-worker
will mistakenly think it needs to load the data off disk in order for the tet worker to be able to return the
results..but in fact, the main will get its data delivered, and the worker won't recompute it, so all that's
bad here is that we laoded a file off disk when we didn't actually need it..and anyway it's probably more or 
less impossible for the delete request to get into the chain in this way.


Just to clarify, the workers do the following: 
    set - always sends header to main, cache uses fkey 
    cut - always sends header+data to main, cache uses fkey 
    pos - always sends header, xy, dir, and speed to main, cache uses object with fkey and post_processing options*
    tet - sends one or more of header, amps, times, gl_data. cache uses fkey
* note that obejcts' identities are not relevant, it's the value of their properties that counts

Note that in the worker we bump parsed data in the FIFO when it is re-requested, but only when the worker
hears about those re-requests.  Perhaps the main thread should send bump signals to the worker when it
uses something from cache.  Exactly what happens to these signals doesn't matter, they're just to improve
the utilization of the cqche.

TODO: angle correction for dir from set file.
-->


<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="worker-builder.html">
<link rel="import" href="utils.html">

<dom-module id="parsed-data">

<script is='worker-builder' id="io_worker" title="io-worker" type='javascript/worker'>
"use strict";

var timer = 0;
var ports = {};
var pending_files = {};
var pending_fkeys = {};
var pending_options = {};
var types = ['tet', 'set', 'pos', 'cut']; // this is the priority order
var parsers_cached_fkeys = {
    tet: new Set(), // tracks which fkeys tet worker currently holds in its cache buffers
    pos: new Set() // same for pos
}
var max_cache_size = 4; // pretty arbitrary, especially as it's not type-specific
var currently_reading;

var got_ports = function(ports_){
    ports = ports_;
    for(let t of types){
        let t_local = t;
        ports[t].onmessage = function(e){
            if(e.data !== 'done reading'){
                throw "bad message from " + t + " to io worker: " + JSON.String(data);
            }
            if (currently_reading === t_local){
                currently_reading = undefined;
                touch_timer();
            }
        }
    }
}

var read_files = function(files, options){
    for(let t of types){
        if(files[t] !== undefined){
            pending_files[t] = files[t];
            pending_options[t] = options[t];
            pending_fkeys[t] = files[t+'_fkey'];
        }
    }
    touch_timer();
}

var touch_timer = function(){
    for(let t of types){
        if(pending_files[t]){
            timer = timer || setImmediate(timer_tick);
            return;
        }
    }
    clearImmediate(timer);
}

var timer_tick = function(){
    timer = 0;
    // if there are any files already cached, then issue those requests immediately
    for(let t of types){
        if(!pending_files[t] || !parsers_cached_fkeys[t]){
            continue;
        }
        let file = pending_files[t];
        let fkey = pending_fkeys[t];
        let cache = parsers_cached_fkeys[t];
        if(cache.has(fkey)){
            // bump in FIFO
            cache.delete(fkey); 
            cache.add(fkey); 
            ports[t].postMessage({
                fkey: fkey,
                name: file.name,
                file: null, // buffer is available at the reciever's end!!
                options: pending_options[t],
                delete_from_cache: null 
            });
            pending_files[t] = undefined;
            pending_fkeys[t] = undefined;
            pending_options[t] = undefined;
        }
    }

    if(currently_reading){
        return; // and do not touch_timer, instead wait for the message from the current reader or from main thread
    }

    // now, load zero or one files from disk and issue request to corresponding worker
    // crucially, we do this in the priority order defined by the types array
    for(let t of types){
        if(!pending_files[t]){
            continue;
        }
        let file = pending_files[t];
        let fkey = pending_fkeys[t];
        let cache = parsers_cached_fkeys[t];
        let delete_from_cache;
        if(cache){
            // note that fkey can't have been in the cache already, because we tested for that in the above loop.
            cache.add(fkey);
            if(cache.size > max_cache_size){
                delete_from_cache = cache.keys().next().value;
                cache.delete(delete_from_cache);
            }
        }
        currently_reading = t; // see note about Chrome bug at top of page
        //let reader = new FileReaderSync();  
        //let buf = reader.readAsArrayBuffer(file);
        ports[t].postMessage({
            fkey: fkey,
            name: file.name,
            file: file,
            options: pending_options[t],
            delete_from_cache: delete_from_cache
        });
        pending_files[t] = undefined;
        pending_options[t] = undefined;
        pending_fkeys[t] = undefined;
        break;
    }

    // and keep going...
    touch_timer();
}
</script>


<script is='worker-builder' id="pos_parser" title="pos-parser" type='javascript/worker'>
"use strict";

var fkey_to_buffer = new Map();
var main_cached_opts = new Set(); // set of objects each giving options and fkey
var max_cache_size = 4; // arbitrary

var got_ports = function(ports){
    self.io_port = ports.pos;
    io_port.onmessage = function(e){
        var fkey = e.data.fkey;
        var buffer = fkey_to_buffer.get(fkey);
        if(!buffer){
            // see note at top of page on Chrome bug
            let reader =  new FileReaderSync();  // see note about Chrome bug at top of page
            buffer = reader.readAsArrayBuffer(e.data.file);
        }
        io_port.postMessage('done reading');

         // add/delete entries in buffer cache, based on instructions from io-worker
        fkey_to_buffer.set(fkey, buffer);
        if(e.data.delete_from_cache){
            fkey_to_buffer.delete(e.data.delete_from_cache);
        }

        // check to see if main cache actually holds the requested data     
        var options = e.data.options;
        options.fkey = fkey;
        for(let cached_opts of main_cached_opts){
            if(is_equal_simple(cached_opts, options)){
                // bump in FIFO
                main_cached_opts.delete(cached_opts);
                main_cached_opts.add(cached_opts);
                return; // nothing to be done
            }
        }
        
        // pre-emptively add to the record of main cache and decide what, if anything, to remove
        main_cached_opts.add(options);
        var delete_from_cache;
        if(main_cached_opts.size > max_cache_size){
            delete_from_cache = main_cached_opts.keys().next().value;
            main_cached_opts.delete(delete_from_cache);
        }

        parse_pos_file(buffer, fkey, options, e.data.name, delete_from_cache);

    }
}


var is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(let aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
}

var swap_16 = function (val) {
    return ((val & 0xFF) << 8) | ((val >> 8) & 0xFF);
}

var take = function(data,offset,stride){
    // takes every stride'th element from data, starting with the offset'th element
    
    var n = data.length/stride;
    var res = new data.constructor(n);
    
    for(let i=0,j=offset;i<n;i++,j+=stride){
        res[i] = data[j];
    }
    return res;
}

var times_in_place = function(src, factor, skip_val){
    for(let i=0;i<src.length;i++)if(src[i] != skip_val){
        src[i] *= factor;
    }
}

var replace_val_in_place = function(src, find, replace){
    for(let i=0;i<src.length;i++)if(src[i] == find){
        src[i] = replace;
    }
}

var sqr = function(a){return a*a;}

var clone = function(a){ 
    if(a.slice){
        return a.slice(0); //for basic arrays and pure arraybuffer
    }else{
        return new a.constructor(a);
    }
}

var minus = function(a, b, c){
    // we subtract b and c from alternate elemetns of a, inplace, nan16 is skipped
    for(let i=0;i<a.length;i++){
        a[i] -= a[i] == nan16? 0 : b;
        i++;
        a[i] -= a[i] == nan16? 0 : c;
    }
}

var regex_header_a = /((?:[\S\s](?!\r\ndata_start))*[\S\s])(\r\ndata_start)/
var regex_header_b = /(\S*) ([\S ]*)/g

var bytes_per_pos_sample = 4 + 2 + 2 + 2 + 2 + 2 + 2 + (2 + 2) ;//the last two uint16s are numpix1 and numpix2 repeated
var nan16 = -32768; //custom nan value, equal to minimum int16 value    

var parse_pos_file = function(buffer, fkey, options, file_name, delete_from_cache){
    var top_str = new TextDecoder('utf-8').decode(buffer.slice(0, 1204+1));
    var match = regex_header_a.exec(top_str);
    if(!match){
        throw 'did not find end of header in pos file.';
    }

    var data_start = match.index + match[0].length;
    var header = {
        file: file_name
    };
    var header_str = match[0];
    while (match = regex_header_b.exec(header_str)){
        header[match[1]] = match[2];
    }

    if (header.pos_format !== "t,x1,y1,x2,y2,numpix1,numpix2"){
        throw "uncregonised pos format used in pos file";
    }
    
    // apply overrides
    for (let k in options.header_override){
        if(header[k] !== undefined){
            header[k+"_original"] = header[k];
        }
        header[k] = header_override[k];
    }

    var data_len_bytes = parseInt(header.num_pos_samples)*bytes_per_pos_sample;

    if(endian == 'L'){
        let data16 = new Int16Array(buffer, data_start, data_len_bytes/2);
        for (let k=0; k<data16.length; k++){ //note that timestamps are 4 bytes, so this is really unhelpful if you want to read timestamps
            data16[k] = swap_16(data16[k]);
        }
    }

    var pos = post_process(buffer, data_start, data_len_bytes, header, options);
    delete options.fkey;

    exec_main_b('got_pos',{
        fkey: fkey,
        header: header,
        options: options,
        xy: 'xy',
        dir: 'dir',
        speed: 'speed',
        delete_from_cache: delete_from_cache,
    }, {
        xy: pos.xy,
        dir: get_dir(pos),
        speed: get_speed(pos)
    });

}



var interp_xy_sub = function(xy,x_a,y_a,x_b,y_b,i,n_nans){
    //interpolates from element i-1 back to i-n_nans, where element i is x_b,y_b and element i-n_nans-1 is x_a,x_b
    var dx = (x_b-x_a)/(n_nans+1);
    var dy = (y_b-y_a)/(n_nans+1);
    for(let j=0;j<n_nans;j++){
        xy[(i-n_nans + j)*2+0] = x_a + (j+1)*dx;
        xy[(i-n_nans + j)*2+1] = y_a + (j+1)*dy; 
    }
}

var interp_xy = function(xy,n_pos){
   /* 
    Interpolates linearly across nan blocks for single xy stream.
    Does it in place.

    TODO: verify that this does exactly what we want
   */

    // Find first (x,y) that is non-nan
    for(var start=0; start<n_pos; start++){
        let ix = start*2+0;
        let iy = start*2+1;
        if(xy[ix] != nan16 && xy[iy] !=nan16)
            break;
    }

    var ix = start*2+0;
    var iy = start*2+1; 
    var x_a = xy[ix];
    var y_a = xy[iy];
    var n_nans = start; //this will cause first non-nan to be copied back through all previous nan values
    for(var i=start;i<n_pos;i++){
        let ix = i*2+0;
        let iy = i*2+1; 
        let x_b = xy[ix];
        let y_b = xy[iy];
        if(x_b == nan16 || y_b == nan16){
            n_nans++;
        }else{
            if(n_nans) 
                interp_xy_sub(xy, x_a, y_a, x_b, y_b, i, n_nans)
            x_a = x_b;
            y_a = y_b;
            n_nans = 0;
        }
    }
    
    if(n_nans) //fill end-nan values with last non-nan val
        interp_xy_sub(xy, x_a, y_a, x_a, y_a, i, n_nans);

}

var smooth_1d_in_place = function(x, stride, k){
    //box car smoothing of length 2*k + 1
    // (If we pretend the stride=1) The first few values of x will be:
    //  x[0] = (x[0] + x[1] + ... + x[k])/(k+1)
    //  x[1] = (x[0] + x[1] + ... + x[k+1])/(k+2)
    //  ... and then we get to..
    //  x[b] = (x[b-k] + ... + x[b] + ... x[b+k])/(2*k+1)
    // and then we ramp down at the end as with the start.
             
    //a couple of checks for unimplemented generalisations...
    if(stride != 2)
        throw("stride must be 2");
    if(2*k+1 > 256)
        throw("smoothing kernel max length is 256")
    if(k==0)
        return; //no smoothing

    /* Note: (a & 0xff) is (a mod 256) */
    var n = x.length/2;
    
    var circ_buff_1 = new x.constructor(256);
    var circ_buff_2 = new x.constructor(256);
    var tot_1 = 0;
    var tot_2 = 0;
    
    //a is the lowest-index in the sum, b is the central and destination index, c is the highgest index in the sum
    var a=-2*k,b=-k,c=0; 
    
    // ramp up part 1: push the first k values into the buffer and sum
    for(;c<k;a++,b++,c++){
        tot_1 += circ_buff_1[c & 0xff] = x[c*2 + 0]; 
        tot_2 += circ_buff_2[c & 0xff] = x[c*2 + 1];
    }
    
    // ramp up part 2: calculate the first k values
    for(;a<0;a++,b++,c++){
        tot_1 += circ_buff_1[c & 0xff] = x[c*2 + 0]; 
        tot_2 += circ_buff_2[c & 0xff] = x[c*2 + 1];
        x[b*2+0] = tot_1 / (c+1);
        x[b*2+1] = tot_2 / (c+1);
    }
        
    // main section
    var d = 2*k+1;
    for(;c<n;a++,b++,c++){
        tot_1 += circ_buff_1[c & 0xff] = x[c*2 + 0]; 
        tot_2 += circ_buff_2[c & 0xff] = x[c*2 + 1];
        x[b*2+0] = tot_1/d;
        x[b*2+1] = tot_2/d;
        tot_1 -= circ_buff_1[a & 0xff]; 
        tot_2 -= circ_buff_2[a & 0xff];
    }
    
    // ramp down: calculate last k values
    for(;b<n;a++,b++,c++){
        x[b*2+0] = tot_1 / (n-a);
        x[b*2+1 ] = tot_2 / (n-a);
        tot_1 -= circ_buff_1[a & 0xff]; 
        tot_2 -= circ_buff_2[a & 0xff];
    }
    
}

var jump_filter = function(xy, n_pos, max_speed, units_per_m, pos_timebase){
    /*
        For a single stream of xy values, it finds the first non-nan point,
        and then checks the speed required to reach the next point, given the
        sampling rate.  If the speed is too high, it skips that point and calcualtes
        the speed required to get to the following point. This continues until,
        the speed requirement is satisfied. The "skipped" points are set to NaN, inplace.
        The number of points skipped over is returned as an integer.
    */

    if(!max_speed)
        return 0;

    var sqr_max_samp_step = sqr(max_speed*units_per_m /pos_timebase);

    // Find first (x,y) that is non-nan
    for(var start=0; start<n_pos; start++){
        let ix = start*2+0;
        let iy = start*2+1;
        if(xy[ix] != nan16 && xy[iy] !=nan16)
            break;
    }
            
    var ix = start*2+0;
    var iy = start*2+1;     
    var x_from = xy[ix];
    var y_from = xy[iy];
    var jump_len = 1;

    // Set big jump sections to nan
    for(let i=start+1,nJumpy=0; i<n_pos; i++){
        let ix = i*2+0;
        let iy = i*2+1;
        // check if this pos is already nan
        // or if (dx^2 + dy^2)/dt^2 is greater than maxSpeed^2, where the d's are relative to the last "good" sample
        if(xy[ix] == nan16 || xy[iy] == nan16){
            xy[ix] = xy[iy] = nan16; //just in case only one or the other was nan
            jump_len++; // note we don't count njumpy here
        }else if ((sqr(x_from-xy[ix]) + sqr(y_from-xy[iy])) / sqr(jump_len) > sqr_max_samp_step ){
            //sample is nan or speed is too large, so make this a jump
            xy[ix] = xy[iy] = nan16; 
            nJumpy++;
            jump_len++;
        }else{
            //speed is sufficiently small, so this point is ok
            jump_len = 1;
            x_from = xy[ix];
            y_from = xy[iy];
        }
    }

    return nJumpy;
}       

var swap = function(a, b, do_swap){
    var n = 0;
    for(let i=0;i<a.length;i++) if(do_swap[i]){
        let tmp = a[i];
        a[i] = b[i];
        b[i] = tmp;
        n++;
    }
    return n;
}

var nanmean_and_std_2 = function(x){
    /* 
        x is nx2 array, we want nancount, nanmean, and nanstd for both columns.
    */

    var sum_1 = 0; var sum_2 = 0;
    var n1 = 0; var n2 = 0;

    for(let i=0; i<x.length/2; i++){
        let i1 = i*2+0;
        let i2 = i*2+1;
        if(x[i1] && x[i1] != nan16){
            n1++;
            sum_1 += x[i1];
        }
        if(x[i2] && x[i2] != nan16){
            n2++;
            sum_2 += x[i2];
        }
    }
    var mean_1 = sum_1/n1; var mean_2 = sum_2/n2;

    // now get sum(sqr(xy-mean_xy)) and use to calculate nanstd...
    sum_1 = 0; sum_2 = 0;  // NOTE: reusing sums vars!!!!
    for (let i=0; i<x.length/2; i++){
        let i1 = i*2+0;
        let i2 = i*2+1;
        if(x[i1] && x[i1] != nan16)
            sum_1 += sqr(x[i1] - mean_1);
        if(x[i2] && x[i2] != nan16)
            sum_2 += sqr(x[i2] - mean_2);
    }
    var std_1 = Math.sqrt(sum_1/n1); var std_2 = Math.sqrt(sum_2/n2);

    return {mean_1: mean_1, mean_2: mean_2, std_1: std_1, std_2: std_2, n_1: n1, n_2: n2};
}

var combine_xy = function(xy_1, xy_2, weight_1, weight_2){
    /*
        xy_1 and xy_2 are both streams of (x,y) values. 
        We combine them into a single stream according to the ratio of the weights.
    */
    var weight_sum = (weight_1 + weight_2);
    var weight_1 = weight_1/weight_sum;
    var weight_2 = weight_2/weight_sum;
    var ret = new xy_1.constructor(xy_1.length);
    for(let i=0;i<xy_1.length/2;i++){
        let ix = 2*i+0;
        let iy = 2*i+1;
        ret[ix] = xy_1[ix]*weight_1 + xy_1[ix]*weight_2;
        ret[iy] = xy_1[iy]*weight_1 + xy_1[iy]*weight_2;
    }
    return ret;
}

var get_dir = function(pos){
    // TODO: if n_led is 1
    var xy_1 = pos.xy_1;
    var xy_2 = pos.xy_2;

    var ret = new Float32Array(xy_1.length/2);
    var pi = 3.14159265;
    for(let i=0;i<xy_1.length/2;i++){
        let ix = 2*i+0;
        let iy = 2*i+1;
        let dy = xy_2[iy] - xy_1[iy];
        let dx = xy_2[ix] - xy_1[ix];
        ret[i] = Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001 ? NaN : (Math.atan2(dy, dx) + 2*pi) % (2*pi);
    }
    return ret;
}

var get_speed = function(pos){
    var xy = pos.xy;
    var ret = new Float32Array(xy.length/2);
    for(let ii=0; ii<xy.length; ii+=2){
         ret[ii>>1] = Math.hypot(xy[ii+2]-xy[ii+0], xy[ii+3]-xy[ii+1]);
    }
    return ret;
}

var post_process = function(buffer, offset_bytes, length_bytes, header, options){
    var data = new Int16Array(buffer, offset_bytes, length_bytes/2);
    var data32 = new Int32Array(buffer, offset_bytes, length_bytes/4);

    var elements_per_pos_sample = bytes_per_pos_sample/2;
    var n_pos = parseInt(header.num_pos_samples); 
    var end = n_pos * elements_per_pos_sample; 
    
    var pos_nan = 1023;

     // for each pos sample take bytes 4-7, and then view them as a pair of int16s 
    var xy_1 = new Int16Array(take(data32, 1, bytes_per_pos_sample/4).buffer);
    replace_val_in_place(xy_1, pos_nan,nan16); //switch from axona custom nan value to our custom nan value
    
    var n_led = 1;
    if (options.use_both_leds){
        // Rather than using colactive header value in set file (which is a massive pain to get asynchrously here)
        // We see if any of the pixel counts are non-zero/non-nan for the second led, to establish how many leds were used.
        var xy_pix = new Int16Array(take(data32, 3, bytes_per_pos_sample/4).buffer);
        replace_val_in_place(xy_pix, pos_nan, nan16); //switch from axona custom nan value to our custom nan value
        for(let i=0; i<n_pos; i++){
            if(xy_pix[i*2 +1] && xy_pix[i*2 +1] != pos_nan){
                n_led = 2;
                break;
            }
        } // if we make it to the end of the loop then n_led reamined as =1.

    }

    var xy_2;
    if(n_led == 2){
         // for each pos sample take bytes 8-11, and then view them as a pair of int16s 
        xy_2 = new Int16Array(take(data32, 2, bytes_per_pos_sample/4).buffer);
        replace_val_in_place(xy_2, pos_nan, nan16); //switch from axona custom nan value to our custom nan value
    
    }
    
    if(options.need_to_subtract_mins){
        var min_x = parseInt(header.window_min_x);
        var min_y = parseInt(header.window_min_y);
        minus(xy_1, min_x, min_y);
        if(n_led == 2)
            minus(xy_2, min_x, min_y);
    }

    var ppm = parseInt(header.pixels_per_metre);
    var units_per_m = 10000;
    times_in_place(xy_1, units_per_m/ppm, nan16); //convert from pixels to milimeters (we use mm because then we can happily use Int16s)
    if(n_led == 2){
        times_in_place(xy_2, units_per_m/ppm, nan16); //convert from pixels to milimeters (we use mm because then we can happily use Int16s)
    }

    if(n_led == 2){
        // check for and apply LED swaping...
        var shrunk_and_switched = new Uint8Array(n_pos);  

        var swapping_thresh = options.swapping_thresh_cm * (units_per_m/100);

        // firstly we check to see if number of pixels for first LED is actually closer to pixel count mean for second led,
        // where "closer" is defined as z-score, i.e. distance/std for the relevant distribution.
        var pix_props = nanmean_and_std_2(xy_pix);
        var weight_1 = pix_props.n_1/n_pos; var weight_2 = pix_props.n_2/n_pos;

        var mean_1 = pix_props.mean_1; var mean_2 = pix_props.mean_2; var std_1 = pix_props.std_1; var std_2 = pix_props.std_2;
        header.post_n_pix_led1 = "mean=" + pix_props.mean_1.toFixed(2) + " std=" + pix_props.std_1.toFixed(2) + " (nan count=" + (n_pos - pix_props.n_1) + ")";
        header.psot_n_pix_led2 = "mean=" + pix_props.mean_2.toFixed(2) + " std=" + pix_props.std_2.toFixed(2) + " (nan count=" + (n_pos - pix_props.n_2) + ")";

        // use std and mean to get z score of pix1 to pix1 and pix2
        for(let i=0; i< n_pos; i++){
            let i1 = i*2+0;
            let i2 = i*2+1;
            if(xy_pix[i1] && xy_pix[i2] && xy_pix[i1] != nan16 && xy_pix[i2] != nan16){
                let z11 = (mean_1 - xy_pix[i1])/std_1;
                let z12 = (xy_pix[i1] - mean_2)/std_2;
                shrunk_and_switched[i] = z11 > z12;
            }
        }


        // Now we calculate jump distance (from time i-1 to time i)
        // four distnaces: led1 to led1, led1 to led2, led2 to led1, led2 to led2.
        // if the recorded version of distance is more than swapping_thresh further
        // than the potential "swapped" version, then consider it a swap.

        // Find first (x,y) that is non-nan on both xy and xy_2
        for(var start=0; start<n_pos; start++){
            let ix = start*2+0;
            let iy = start*2+1;
            if(xy_1[ix] != nan16 && xy_1[iy] !=nan16 && xy_2[ix] != nan16 && xy_2[iy] !=nan16)
                break;
        }

        for(let i = start+1; i<n_pos; i++)if(shrunk_and_switched[i]){
            // we are going to do diffs with XY_i - XY_(i-1)
            let ix = i*2+0;
            let iy = i*2+1;
            let i_1x = i*2-2;
            let i_1y = i*2-1;
            if(xy_1[ix] == nan16 || xy_1[iy] == nan16 || xy_2[ix] == nan16 || xy_2[iy] == nan16){
                shrunk_and_switched[i] = 0;
                i++; // skip next iteration as well becuase the current index cannot be used as i, or as (i-1)
                shrunk_and_switched[i] = 0;
                continue; 
            }

            let dist12 = Math.hypot(xy_1[ix] - xy_2[i_1x],  xy_1[iy] - xy_2[i_1y]);
            let dist11 = Math.hypot(xy_1[ix] - xy_1[i_1x],  xy_1[iy] - xy_1[i_1y]);
            let dist21 = Math.hypot(xy_2[ix] - xy_1[i_1x],  xy_2[iy] - xy_1[i_1y]);
            let dist22 = Math.hypot(xy_2[ix] - xy_2[i_1x],  xy_2[iy] - xy_2[i_1y]);

            shrunk_and_switched[i] = (dist12 < dist11-swapping_thresh) && (dist21 < dist22 - swapping_thresh);

        }

        // Swap xy_1 with xy_2 where we decided we need to swap. (Note we use 32bit to swap 2x16bit xy in one go)
        header.post_n_swapped = swap(new Uint32Array(xy_1.buffer), new Uint32Array(xy_2.buffer), shrunk_and_switched);
    }
    
    var pos_timebase = parseInt(header.sample_rate);
    header.post_n_jumpy_led1 = jump_filter(xy_1, n_pos, options.max_speed, units_per_m, pos_timebase)
    if(n_led == 2){
         header.post_n_jumpy_led2 = jump_filter(xy_2, n_pos, options.max_speed, units_per_m, pos_timebase);
    }
    
    interp_xy(xy_1,n_pos);
    if(n_led == 2){
        interp_xy(xy_2,n_pos);
    }

    var k = Math.floor(pos_timebase*options.smoothing_secs/2); //the actual filter will be of length k*2+1, which means it may be one sample longer than desired         
    smooth_1d_in_place(xy_1, 2, k);
    var xy;
    if(n_led == 2){
        smooth_1d_in_place(xy_2, 2, k);
        xy = combine_xy(xy_1, xy_2, weight_1, weight_2);
    }else{
        xy = xy_1;
    }

    header.max_vals = [(parseInt(header.window_max_y)-parseInt(header.window_min_y))*units_per_m/ppm ,
                       (parseInt(header.window_max_x)-parseInt(header.window_min_x))*units_per_m/ppm ]; //TODO: decide which way round we want x and y
    header.units_per_meter = units_per_m;

    return {
        xy: xy,
        xy_1: xy_1,
        xy_2: xy_2,
        header: header
    }
}

</script>


<script is='worker-builder' id="tet_parser" title="tet-parser" type='javascript/worker'>
"use strict";
// TODO: it might be nice, though complicated, to batch the tet parsing, that would
// allow the io to overlap with the compute, both of which are about 1ms/1k spikes.

var fkey_to_buffer = new Map();

var main_cached_opts = new Set();
var max_cache_size = 4; //aribtrary

var got_ports = function(ports){
    self.io_port = ports.tet;
    io_port.onmessage = function(e){
        var fkey = e.data.fkey;
        var buffer = fkey_to_buffer.get(fkey);
        if(!buffer){
            // see note at top of page on Chrome bug
            let reader =  new FileReaderSync();  // see note about Chrome bug at top of page
            buffer = reader.readAsArrayBuffer(e.data.file);
        }
        io_port.postMessage('done reading');

        // add/delete entries in buffer cache, based on instructions from io-worker
        fkey_to_buffer.set(fkey, buffer);
        if(e.data.delete_from_cache){
            fkey_to_buffer.delete(e.data.delete_from_cache);
        }

        // check to see if main cache actually holds any of the requested data 
        var options = e.data.options;       
        options.fkey = fkey;
        for(var cached_opts of main_cached_opts){
            if(cached_opts.fkey === fkey){
                // bump in FIFO
                main_cached_opts.delete(cached_opts);
                main_cached_opts.add(cached_opts);
                fkey_in_cache = cached_opts;
                // remove the things that are already in cache
                if(cached_opts.times){
                    delete options.times;
                }
                if(cached_opts.amps){
                    delete options.amps;
                }
                if(cached_opts.gl_data){
                    delete options.gl_data;
                }
                if(options.times || options.amps || options.gl_data){
                    break; // there is at least some work to be done
                } else{
                    return; // nothing new requested
                }
            }
        }   

        if (!cached_opts || cached_opts.fkey !== fkey){
            // create new entry in main cache record, and possibly delete something
            cached_opts = {fkey: fkey};
            main_cached_opts.add(cached_opts);
            if(main_cached_opts.size > max_cache_size){
                var delete_from_cache = main_cached_opts.keys().next().value;
                exec_main('delete_from_tet_cache', delete_from_cache);
                main_cached_opts.delete(delete_from_cache);
            }
        }

        // pre-emptively record what we are about to put in main cache
        if(options.times){
            cached_opts.times = 1;
        }
        if(options.gl_data){
            cached_opts.gl_data = 1;
        }
        if(options.amps){
            cached_opts.amps = 1;
        }

        // and actually do the work...
        parse_tet_file(buffer, fkey, options, e.data.name);

    }
}

var regex_header_a = /((?:[\S\s](?!\r\ndata_start))*[\S\s])(\r\ndata_start)/
var regex_header_b = /(\S*) ([\S ]*)/g
var data_end = "\r\ndata_end";
var n_c = 4;
var n_w = 50;
var bytes_per_spike = n_c*(4 + n_w);

var parse_tet_file = function(buffer, fkey, options, file_name){
    var top_str = new TextDecoder('utf-8').decode(buffer.slice(0, 1204+1));
        
    var match = regex_header_a.exec(top_str);
    if(!match){
        throw 'did not find end of header in tet file.';
    }

    var data_start = match.index + match[0].length;
    var header = {
        file: file_name
    };
    var header_str = match[0];
    while (match = regex_header_b.exec(header_str)){
        header[match[1]] = match[2];
    }

    if (header.spike_format !== "t,ch1,t,ch2,t,ch3,t,ch4"){
        throw "uncregonised spike format used in tet file";
    }
    
    // sometimes DaCQ creates a header with num_spikes >0, but there are no spikes
    // (this happens when you choose not to record a given tetrode but a file previously existed)
    if(top_str.slice(data_start, data_start + data_end.length) === data_end){
        header.num_spikes_claimed = header.num_spikes;
        header.num_spikes = 0;
    }
    var n = parseInt(header.num_spikes);
    var data_len_bytes = n*bytes_per_spike;

    exec_main('got_tet_header', fkey, header);

    // TODO: test whether it's faster to iterate over the data once and compute everything
    // or to iterate once for each thing of interest (which is a bit more complicated)
    // if we stick with the multiple separate iterations, then decide on a good priority order
    // that gives users the best perception of speed...gl data probably comes first as it is
    // worth having even without cut data, whereas the other two are less helpful without cut
    // data.

    if(options.gl_data){
        var data =  build_gl_data(buffer, data_start, data_len_bytes, n);
        exec_main_b('got_gl_data', {
            data: 'data', 
            fkey: fkey,
            n_spikes: n
        }, {data: data});
    }

    if(options.times){
        var data =  get_times(buffer, data_start, data_len_bytes, n);
        exec_main_b('got_times', {
            data: 'data', 
            fkey: fkey,
            n_spikes: n,
            timebase: parseInt(header.timebase),
        }, {data: data});
    }

    if(options.amps){
        var data = get_amplitudes(buffer, data_start, data_len_bytes, n);
        exec_main_b('got_amplitudes', {
            data: 'data', 
            fkey: fkey,
            n_spikes: n
        }, {data: data});
    }
}

var build_gl_data_sub = function(data_in, data_out_16, n_spikes){
    // Note how we read from data_in contiguously, but write out non-contiguously.
    // This is about 4x faster than doing it the other way around.
    // It takes about 80ms for 80k spikes.
    // DataView should allow for fast misaligned uint16 access of data_in, but currently it's slow...
    // https://bugs.chromium.org/p/chromium/issues/detail?id=225811. Even if it's optimized in chrome
    // it probably won't help by more than 5-10% I would think.

    var q = -1;
    var i, p;
    for(i=0, p=0;i<n_spikes;i++,p=i){ //for each spike
        for(let c=0;c<n_c;c++){ //for each channel
            q += 5;
            for(let t=0;t<n_w-1;t++){ //for each time point (except the last one)
                data_out_16[p] = data_in[q] | (data_in[++q] << 8); // TODO: deal properly with endianness of system 
                // (Note that even though we are drawing a stand alone line segment from a to b, we still need to know how they match up to times t and t+1)
                p += n_spikes;
            }
        }
    }
}

var build_gl_data = function(buffer, offset_bytes, length_bytes, n_spikes){
    var old_data = new Uint8Array(buffer, offset_bytes, length_bytes);
    var new_data = new Uint16Array(n_c*(n_w-1)*n_spikes);
    
    build_gl_data_sub(old_data, new_data, n_spikes);
    return new_data;        
}


var get_times = function(buffer, offset_bytes, length_bytes, n_spikes){ //get spike times in milliseconds as a Uint32Array 
    var times = new Uint32Array(n_spikes);
    var data8 = new Uint8Array(buffer, offset_bytes, length_bytes); // can't make this int32 because it may not be sufficeintly alligned

    if (endian === 'L') {
        for(let i=0, p=0; i<times.length; i++, p+= bytes_per_spike){
            times[i] = (data8[p+0] << 24)
                     | (data8[p+1] << 16)   
                     | (data8[p+2] << 8) 
                     | (data8[p+3] << 0); 
        }        
    } else {
        throw "need to implement for big endian"; // TODO: or maybe the version above is actually valid for bothered?
    }

    return times;
}

var get_amplitudes_sub = function(old_data, amps, n_sc, n_w){
    n_sc = n_sc | 0; // int
    n_w = n_w | 0; // int
    for(let i=0, p=0; i<n_sc; i++){
        p += 4; // skip timestamp 
        let min = 127;
        let max = -128;
        for(let t=0; t<n_w; t++,p++){
            (old_data[p] > max) && (max = old_data[p]);
            (old_data[p] < min) && (min = old_data[p]);
        }
        amps[i] = max-min; 
    }
}

var get_amplitudes = function(buffer, offset_bytes, length_bytes, n_spikes){
    var old_data = new Int8Array(buffer, offset_bytes, length_bytes);
    var amps = new Uint8Array(n_spikes * n_c);
    get_amplitudes_sub(old_data, amps, n_spikes * n_c, n_w);
    return amps;
}

</script>


<script is='worker-builder' id="set_parser" title="set-parser" type='javascript/worker'>
"use strict";

var max_cache_size = 4; // arbitrary
var main_cached_fkeys = new Set();
var fkey_to_buffer = new Map();

var got_ports = function(ports){
    self.io_port = ports.set;
    io_port.onmessage = function(e){
        var fkey = e.data.fkey;
        var buffer = fkey_to_buffer.get(fkey);
        if(!buffer){
            // see note at top of page on Chrome bug
            let reader =  new FileReaderSync();  // see note about Chrome bug at top of page
            buffer = reader.readAsArrayBuffer(e.data.file);
        }
        io_port.postMessage('done reading');

        // add/delete entries in buffer cache, based on instructions from io-worker
        fkey_to_buffer.set(fkey, buffer);
        if(e.data.delete_from_cache){
            fkey_to_buffer.delete(e.data.delete_from_cache);
        }

        if(main_cached_fkeys.has(fkey)){
            // bump in FIFO
            main_cached_fkeys.delete(fkey);
            main_cached_fkeys.add(fkey);
            return;
        }
        var full_str = new TextDecoder('utf-8').decode(buffer);
        
        main_cached_fkeys.add(fkey);
        var delete_from_cache;
        if(main_cached_fkeys.size > max_cache_size){
            delete_from_cache = main_cached_fkeys.keys().next().value;
            main_cached_fkeys.delete(delete_from_cache);
        }

        var header = parse_set_file(full_str, fkey);
        header.file = e.data.name;
        exec_main('set_file_parsed', {
            fkey: fkey,
            header: header,
            delete_from_cache: delete_from_cache});

    }
}

var regex_header_b = /(\S*) ([\S ]*)/g

var parse_set_file = function(full_str, fkey){
    var header = {};
    var match;
    while (match = regex_header_b.exec(full_str))
        header[match[1]] = match[2];
    return header;
}

</script>


<script is='worker-builder' id="cut_parser" title="cut-parser" type='javascript/worker'>
"use strict";

var max_cache_size = 4; // arbitrary
var main_cached_fkeys = new Set();
var regex_ext = /\.([0-9a-z]+)$/i;
var fkey_to_buffer = new Map();

var got_ports = function(ports){
    self.io_port = ports.cut;
    io_port.onmessage = function(e){
        var fkey = e.data.fkey;
        var buffer = fkey_to_buffer.get(fkey);
        if(!buffer){
            // see note at top of page on Chrome bug
            let reader =  new FileReaderSync();  // see note about Chrome bug at top of page
            buffer = reader.readAsArrayBuffer(e.data.file);
        }
        io_port.postMessage('done reading');

        // add/delete entries in buffer cache, based on instructions from io-worker
        fkey_to_buffer.set(fkey, buffer);
        if(e.data.delete_from_cache){
            fkey_to_buffer.delete(e.data.delete_from_cache);
        }

        if(main_cached_fkeys.has(fkey)){
            // bump in FIFO
            main_cached_fkeys.delete(fkey);
            main_cached_fkeys.add(fkey);
            return; // main already has it, so no need to send it.
        }
        var full_str = new TextDecoder('utf-8').decode(buffer);

        // TODO: clu/cut based on extension
        var ext = e.data.name.match(regex_ext)[1]
        var msg;
        if (ext === 'cut') {
            msg = parse_cut_file(full_str, fkey);
        } else if(!isNaN(parseInt(ext))){
            msg = parse_clu_file(full_str, fkey);
        } else{
            throw "urecognised cut type";
        }
        
        var cut = msg.cut;
        msg.cut = "cut";
        msg.fkey = fkey;
        msg.header.file = e.data.name;
        main_cached_fkeys.add(fkey);
        if(main_cached_fkeys.size > max_cache_size){
            msg.delete_from_cache = main_cached_fkeys.keys().next().value;
            main_cached_fkeys.delete(msg.delete_from_cache);
        }

        exec_main_b('cut_file_parsed', msg, {cut : cut});

    }
}

var regex_cut_a = /n_clusters:\s*(\S*)\s*n_channels:\s*(\S*)\s*n_params:\s*(\S*)\s*times_used_in_Vt:\s*(\S*)\s*(\S*)\s*(\S*)\s*(\S*)/;
var regex_cut_b = /Exact_cut_for: ((?:[\s\S](?! spikes:))*[\s\S])\s*spikes: ([0-9]*)/;
var regex_cut_c = /([0-9]+)/g;
var max_length_match_cut_b = 300;//this is needed so that when we read in chunks of the cut fkey we dont have to apply the regex_b to the whole thing each time

var parse_cut_file = function(full_str, fkey){
    var match = regex_cut_a.exec(full_str);      
    var cut_props = {};
    cut_props.n_clusters =  parseInt(match[1]);
    cut_props.n_channels =  parseInt(match[2]);
    cut_props.n_params =  parseInt(match[3]);

    match = regex_cut_b.exec(full_str);
    cut_props.exp = match[1];
    cut_props.n_spikes = parseInt(match[2]);
    cut_props.data_start = match.index + match[0].length;
    cut_props.is_clu = false;

    var cut_as_str = full_str.slice(cut_props.data_start).match(regex_cut_c);
    var cut = new Uint32Array(cut_as_str.length);
    for(let ii=0; ii<cut.length; ii++){
        cut[ii] = parseInt(cut_as_str[ii]);
    }

    return {
        header: cut_props,
        cut: cut
    }

}

var parse_clu_file = function(full_str, fkey){
    var cut_as_str = full_str.match(regex_cut_c);
    var cut_props = {
        n_clusters: parseInt(cut_as_str[0]),  // TODO: check +/- 1
        n_spikes: cut_as_str.length-1,
        is_clu: true
    }
    var cut = new Uint32Array(cut_as_str.length-1);
    for(let ii=0; ii<cut.length; ii++){
        cut[ii] = parseInt(cut_as_str[ii+1]) -1;
    }

    return {
        header: cut_props,
        cut: cut
    }
}

</script>

<template></template>


<script>
    "use strict";
    Polymer({
        is:'parsed-data',
        properties: {
            selected_files: {
                type: Object,
                value: function(){return {set: 0, pos: 0, tet: 0, cut: 0}},
                notify: true,
                observer: '_change_to_files'
            },
            use_n_leds: {
                type: Number, //1 or 2
                value: 2
            },
            speed_filter_mps: {
                type: Number,  //mps= meters per second
                value: 4
            },
            pos_smoothing_s: {
                type: Number, 
                value: 0.2
            },
            duration: {
                type: Number, // seconds
                value: 0,
                notify: true,
                readOnly: true
            },
            spike_times: {
                type: Object,
                value: function(){ return {};}, // data (akey), timebase
                readOnly: true,
                notify: true
            },
            pos_xy: {
                type: Object,
                value: function(){ return {};}, // data (akey), timebase,  and units_per_cm
                readOnly: true,
                notify: true 
            },
            pos_dir: {
                type: Object,
                value: function(){ return {};}, // data (akey), timebase
                readOnly: true,
                notify: true
            },
            pos_speed: {
                type: Object,
                value: function(){ return {};}, // data (akey), timebase
                readOnly: true,
                notify: true
            },
            pos_header: {
                type: Object,
                value: function(){ return {};},
                readOnly: true,
                notify: true
            },
            set_header: {
                type: Object,
                value: function(){ return {};},
                readOnly: true,
                notify: true
            },
            tet_header: {
                type: Object,
                value: function(){ return {};},
                readOnly: true,
                notify: true
            },
            cut_box: {
                type: Object, // is: ["stack" | "file" | "n" | <undefined> ]
                              // is="file". akey: indices for file, header: header for file
                              // is="n". n_spikes in tet file
                              // is="stack". see cut-obj for details
                value: function(){ return {} },
                readOnly: true,
                notify: true
            },
            amplitudes: {
                type: String,
                value: "", // typed-array-manager id
                notify: true,
                readOnly: true
            },
            data_for_gl: {
                type: Object,
                value: function(){return {};}, // has n value and typed-array-manager id for gl voltages
                readOnly: true,
                notify: true
            },
            want_spike_times: {
                type: Boolean,
                value: true,
                notify: true
            },
            want_amplitudes: {
                type: Boolean,
                value: true,
                notify: true
            },
            want_data_for_gl: {
                type: Boolean,
                value: true,
                notify: true
            }
        }, observers: [
            '_pos_options_changed(speed_filter_mps, use_n_leds, pos_smoothing_s)',
            '_tet_options_changed(want_spike_times, want_data_for_gl, want_amplitudes)'
        ], created: function(){
            this._files = {}; // set, tet, pos, cut
            this._fkeys = {}; // set, tet, pos, cut
            this._cut_from_fkey = new Map();
            this._set_from_fkey = new Map();
            this._pos_from_options = new Map(); // key=options object giving fkey and parse options; value= {header, xy, dir, speed}
            this._tet_from_fkey = new Map(); // contains objects with one or more of {header, amps, times, gl_data}

            // this is slightly gratuitous as the set worker and cut workers really don't do all that much
            // but it's unlikely to be worse having them as workers.
            this._worker_io = Polymer.DomModule.import('parsed-data', '#io_worker').create_for(this);
            this._worker_set = Polymer.DomModule.import('parsed-data', '#set_parser').create_for(this);
            this._worker_tet = Polymer.DomModule.import('parsed-data', '#tet_parser').create_for(this);
            this._worker_pos = Polymer.DomModule.import('parsed-data', '#pos_parser').create_for(this);
            this._worker_cut = Polymer.DomModule.import('parsed-data', '#cut_parser').create_for(this);
            var ports_for_io = {};

            var c = new MessageChannel();
            ports_for_io['set'] = c.port1;
            this._worker_set.send_ports({set: c.port2});

            c = new MessageChannel();
            ports_for_io['tet'] = c.port1;
            this._worker_tet.send_ports({tet: c.port2});

            c = new MessageChannel();
            ports_for_io['pos'] = c.port1;
            this._worker_pos.send_ports({pos: c.port2});

            c = new MessageChannel();
            ports_for_io['cut'] = c.port1;
            this._worker_cut.send_ports({cut: c.port2});

            this._worker_io.send_ports(ports_for_io);

        }, attached: function(){
            var els = document.getElementsByTagName('cut-object');
            for(let ii=0; ii<els.length; ii++){
                els[ii].addEventListener('fork', this._cut_forked.bind(this));
            }
        }, _cut_forked: function(e){
            // We catch this signal from the cut-obj directly, in addition to the file-organiser catching it.
            // By doing this, when the file-organiser changes its file_selection, we will not treat the forked cut
            // as being new..which is great.  Note that setting the cut_box here will send it to the cut obj, but the
            // cut object will find that each inidvidual property is the same as before, so will not actually do anything.
            // Another thing to note is that file_selection is updated from within a debounce in file-organiser, which ensures
            // that this event handler is called before the file-organiser notifies us of the change.
            this._fkeys.cut = e.detail;
            this._files.cut = Utils.file_manager.get_file(this._fkeys.cut);
            this._setCut_box(this._files.cut);
        }, _change_to_files: function(new_fkeys){
            // nullify things that are changing... (note we this._fkeys rather than 2nd argument, old_fkeys due to _cut_forked)
            var changing = new Set();
            for(let k of ['tet','cut','pos','set']){
                if(!this._fkeys[k] || this._fkeys[k] !== new_fkeys[k]){
                    changing.add(k);
                    this._files[k] = Utils.file_manager.get_file(new_fkeys[k]) || null;
                }
            }
            if(changing.has('tet') && this._fkeys.cut && this._fkeys.cut.is === "n"){
                changing.add('cut');
            }
            this._fkeys = Utils.simple_clone(new_fkeys);
            this.fire('start_nulling', changing);

            if(changing.has('set')){
                this._setDuration(null);
                this._setSet_header(null);
            }
            if(changing.has('pos')){
                this._setPos_xy(null);
                this._setPos_speed(null);
                this._setPos_dir(null);
                this._setPos_header(null);
            }
            if(changing.has('tet')){
                this._setSpike_times(null);
                this._setAmplitudes(null);
                this._setData_for_gl(null);
                this._setTet_header(null);
            }
            if(changing.has('cut')){
                this._setCut_box(null);
            }

            this.fire('end_nulling');

            // build request for io-worker, taking as much as possible from the main cache
            var request = {};
            var options = {};

            if(changing.has('set')){
                request['set'] = null;
                if(new_fkeys.set && this._set_from_fkey.has(new_fkeys.set)){
                    this._use_set(this._set_from_fkey.get(new_fkeys.set));
                } else {
                    request['set'] = this._files.set;
                    request['set_fkey'] = new_fkeys.set;
                }
            }

            if(changing.has('cut')){
                this._make_cut_from_n = false;
                request['cut'] = null;
                if(!new_fkeys.cut){
                    this._make_cut_from_n = true; // we have already guaranteed that changing has 'tet'
                                                  // though if there's no tet file we will never get to make the cut
                } else if(this._files.cut.is === "stack"){
                    // new_values.cut is an fkey for a "fake" file, which is actually a cut "stack" object
                    this._setCut_box(this._files.cut); //easy
                } else {
                    // new_fkeys.cut is an fkey for a proper file
                    if(this._cut_from_fkey.has(new_fkeys.cut)){
                        // create box from cached inds and header
                        this._setCut_box({
                            is: 'file',
                            akey: this._cut_from_fkey.get(new_fkeys.cut).cut,
                            header: this._cut_from_fkey.get(new_fkeys.cut).header
                        });
                    } else {
                        request['cut'] = this._files.cut;
                        request['cut_fkey'] = new_fkeys.cut;
                    }
                }
            }

            if(changing.has('pos')){
                request['pos'] = null;
                if(new_fkeys.pos){
                    var in_cache = false;
                    var pos_options = this._make_pos_options();
                    pos_options.fkey = new_fkeys.pos;
                    for(let [cached_opts, data] of this._pos_from_options){
                        if(Utils.is_equal_simple(cached_opts, pos_options)){
                            this._use_pos(data);
                            in_cache = true;
                            break;
                        }
                    }
                    if(!in_cache){
                        request['pos'] = this._files.pos;
                        options['pos'] = this._make_pos_options();
                        request['pos_fkey'] = new_fkeys.pos;
                    }
                }
            }

            if(changing.has('tet')){
                this._make_tet_request(new_fkeys.tet, this._files.tet, request, options);
            }

            this._worker_io.exec('read_files', request, options); 

        }, _pos_options_changed: function(){
            var options = this._make_pos_options();
            this._worker_io.exec('read_files', {
                pos: this._files.pos,
                pos_fkey: this.selected_files.pos
            }, {
                pos: options
            });
        }, got_pos: function(msg, arrays){
            var am = Utils.typed_array_manager;
            var result = {
                xy: am.store_array(arrays['xy']),
                dir: am.store_array(arrays['dir']),
                speed: am.store_array(arrays['speed']),
                header: msg.header
            };
            msg.options.fkey = msg.fkey; // needed both for adding to cache (on next line) and for delete_from_cache loop
            this._pos_from_options.set(msg.options, result);
            if(msg.delete_from_cache){
                for(let [cached_opts, ignore] of this._pos_from_options){
                    if(Utils.is_equal_simple(cached_opts, msg.delete_from_cache)){
                        this._pos_from_options.delete(cached_opts);
                    }
                }
            }
            var opts =  this._make_pos_options();
            opts.fkey = this.selected_files.pos;
            if(Utils.is_equal_simple(msg.options, opts)){
                this._use_pos(result);
            }            
        },
        _use_pos: function(result){
            this._setPos_xy(result.xy);
            this._setPos_dir(result.dir);
            this._setPos_speed(result.speed);
            this._setPos_header(result.header);
        },
        _make_tet_request: function(fkey, file, request, options){
            if(!fkey){
                request['tet'] = null;
                return;
            }

            var cached = this._tet_from_fkey.get(fkey) || {};
            options['tet'] = {};
            if(this.want_amplitudes){
                if(cached.amps){
                    this._setAmplitudes(cached.amps);
                } else {
                    request['tet'] = file;
                    request['tet_fkey'] = fkey;
                    options['tet']['amps'] = 1;    
                }
            } 
            if(this.want_spike_times){
                if(cached.times){
                    this._setSpike_times(cached.times);
                } else {
                    request['tet'] = file;
                    request['tet_fkey'] = fkey;
                    options['tet']['times'] = 1;
                }
            }
            if(this.want_data_for_gl){
                if(cached.gl_data) {
                    this._setData_for_gl(cached.gl_data);
                } else {
                    request['tet'] = file;
                    request['tet_fkey'] = fkey;
                    options['tet']['gl_data'] = 1;                            
                }
            }
            if(cached.header){
                this._setTet_header(cached.header);
                if(this._make_cut_from_n){
                    this._setCut_box({
                        is: 'n',
                        n_spikes: parseInt(cached.num_spikes)
                    });
                }

            }

        }, _tet_options_changed: function(){
            var request = {}, options = {};
            this._make_tet_request(this.selected_files.tet, this._files.tet, request, options);
            this._worker_io.exec('read_files', request, options); 
        }, cut_file_parsed: function(msg, arrays){
            var am = Utils.typed_array_manager;
            this._cut_from_fkey.set(msg.fkey,{
                header: msg.header,
                cut: am.store_array(arrays['cut'])
            });
            if(this.selected_files.cut === msg.fkey){
                this._setCut_box({
                    is: 'file',
                    akey: this._cut_from_fkey.get(msg.fkey).cut,
                    header: this._cut_from_fkey.get(msg.fkey).header
                });
            }
            if(msg.delete_from_cache){
                this._cut_from_fkey.delete(msg.delete_from_cache);
            }
        }, _make_pos_options: function(){
            return {
                use_both_leds: this.use_n_leds,
                need_to_subtract_mins: false,
                swapping_thresh_cm: 1,
                max_speed: this.pos_filter_mps,
                smoothing_secs: this.pos_smoothing_s
            }
        }, got_gl_data: function(msg, arrays){
            var am = Utils.typed_array_manager;
            var cached = this._tet_from_fkey.get(msg.fkey);
            if(!cached){
                cached = {};
                this._tet_from_fkey.set(msg.fkey, cached);
            }
            cached.gl_data = {
                n: msg.n_spikes,
                voltages: am.store_array(arrays.data)
            };
            if(msg.fkey === this.selected_files.tet){
                this._setData_for_gl(cached.gl_data);
            }
        }, got_amplitudes: function(msg, arrays){
            var am = Utils.typed_array_manager;
            var cached = this._tet_from_fkey.get(msg.fkey);
            if(!cached){
                cached = {};
                this._tet_from_fkey.set(msg.fkey, cached);
            }
            cached.amps = {
                n: msg.n_spikes,
                amps: am.store_array(arrays.data)
            };
            if(msg.fkey === this.selected_files.tet){
                this._setAmplitudes(cached.amps);
            }
        }, got_times: function(msg, arrays){
            var am = Utils.typed_array_manager;
            var cached = this._tet_from_fkey.get(msg.fkey);
            if(!cached){
                cached = {};
                this._tet_from_fkey.set(msg.fkey, cached);
            }
            cached.times = {
                n: msg.n_spikes,
                timebase: msg.timebase,
                times: am.store_array(arrays.data)
            };
            if(msg.fkey === this.selected_files.tet){
                this._setSpike_times(cached.times);
            }
        }, got_tet_header: function(fkey, header){
            var cached = this._tet_from_fkey.get(fkey);
            if(!cached){
                cached = {};
                this._tet_from_fkey.set(fkey, cached);
            }
            cached.header = header;
            if(fkey === this.selected_files.tet){
                this._setTet_header(header);
                if(this._make_cut_from_n){
                    this._setCut_box({
                        is: 'n',
                        n_spikes: parseInt(header.num_spikes)
                    })
                }
            }
        }, delete_from_tet_cache: function(fkey){
            this._tet_from_fkey.delete(fkey);
        }, set_file_parsed: function(msg) {
            if(this.selected_files.set === msg.fkey){
                this._use_set(msg.header);
            }
            this._set_from_fkey.set(msg.fkey, msg.header);
            if(msg.delete_from_cache){
                this._set_from_fkey.delete(msg.delete_from_cache);
            }
        }, _use_set: function(header){
            this._setDuration(parseInt(header.duration));
            this._setSet_header(header);
        }
    });
</script>

  
</dom-module>
