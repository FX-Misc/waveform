<!--
CUSTOM ELEMENT: tac-plots
BY: DM

Note: the variable prefix "taid" means typed-array-manager id.  "groups_idx" means the (scalar) index in the "groups"
array, i.e. which on-screen cut-group are we talking about?  The actual indices into the spike data are refered to
less consistently, in the worker they are stored in taid_to_array.

This is designed to be used inside a tile-wall element.  The "groups" array of the tilewall should be bound
to this element's "groups" property.  Then whenever the tilewall's groups array is spliced this element will
be notified and can update ratemaps acordingly, with the tilewall be notified of the updates.

The main thread maintains a private map, "rendered_canvases", which maps from group.inds (a typed-array-manager id) 
to canvas and render settings.  The worker independantly keeps an analgous map, that includes only render settings 
(not the canvases).  The two maps are kept in sync by virtue of a strict agreement on mutation logic: whenever the 
worker sends an id+canvas+settings unit to the main thread it must store the unit, displacing anything that previously 
existed for the given id.  Whenever the settings change, the main thread informs the worker, and they can then both 
independently check which id's need to have new canvases generated (some may already have the correct render settings 
if the user has gone back and forth fast enough).  Note that the two maps may not be in sync at a specific moment in time,
but the chronological "narative" of changes to the map and changes to the settings will be the same on both threads, and
this is sufficient.
When the main thread is informed that some group.inds are no longer required, it sends a message to the worker thread to
free them.
The main thread also maintains a map from groups index into its rendered_canvases map. This is needed for looking up where
to send canvases as they come back from the worker, it's also needed for working out what taids to delete when a specific 
group gets a new inds taid.

-->


<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="worker-builder.html">

<dom-module id="tac-plots">

<script is='worker-builder' id="worker" title="tac-plots" type='javascript/worker'>
"use strict";

var render_options = {
    max_delta_t: undefined,
    n_bins: 100
};
var spike_times;
var taid_to_array = {}; // Note that in the worker, taid's are used only for arrays of spike-indices.
var taid_to_rendered_options = {}; 
var taids_pending_render = [];
var timer;

var set_max_delta_t = function(v){
    render_options.max_delta_t = v;
    taids_pending_render = [];    
    if(spike_times){
        for(var taid in taid_to_array) if(taid_to_array.hasOwnProperty(taid))
            taids_pending_render.push(taid);
    }
    toggle_timer();
}

var set_spike_times = function(arrays){
    spike_times = arrays.spike_times; 
    taids_pending_render = [];    
    if(spike_times){
        for(var taid in taid_to_array) if(taid_to_array.hasOwnProperty(taid))
            taids_pending_render.push(taid);
    }
    toggle_timer();
}

var update_taids = function(changes, arrays){
    // both add_taids and remove_taids are arrays of ta-maanger ids
    // the actual arrays for add_taids are in the arrays map.

    var remove_taids = changes.remove || [];
    for(var ii=0; ii<remove_taids.length; ii++){
        delete taid_to_array[remove_taids[ii]];
        delete taid_to_rendered_options[remove_taids[ii]];
    }

    var add_taids = changes.add || [];
    for(var ii=0; ii<add_taids.length; ii++){
        taid_to_array[add_taids[ii]] = arrays[add_taids[ii]];
        taids_pending_render.push(add_taids[ii]);
    }

    toggle_timer();        
}

var toggle_timer = function(){
    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from main thread to interupt
    // between ticks, we can thus cancel work as an when needed.
    if(spike_times && taids_pending_render.length)
        timer = timer || setImmediate(timer_tick);
    else
        clearImmediate(timer);
}

var timer_tick = function(){
    timer = 0;
    var taid = taids_pending_render.pop();
    
    if(taid && taid_to_array[taid] && !is_equal_simple(taid_to_rendered_options[taid], render_options))
        get_group_hist(taid);

    toggle_timer();
}

var get_group_hist = function(taid){
    // note desired_max_delta_t and spike_times should both be in the same units
    var group_times = pick(spike_times, taid_to_array[taid]);

    // build pairwise-diff histogram
    var ret = new Uint32Array(render_options.n_bins+1);
    get_group_hist_sub(ret, group_times, render_options.max_delta_t, 
                        render_options.max_delta_t/render_options.n_bins);
 
    taid_to_rendered_options[taid] = clone_simple(render_options);
    exec_main_b('plot_hist', {
        taid: taid,
        hist_name: 'hist',
        render_options: taid_to_rendered_options[taid]
    }, {hist: ret});
}

var get_group_hist_sub = function(ret, group_times, D, b){
    // For every pair of spikes separated in time by no more than time D, bin
    // up the time separation, with bin size b, and record it in hist, ret.
    for(var later_idx=1, earlier_idx=0; later_idx<group_times.length; later_idx++){
        var laterTime = group_times[later_idx];
        while (group_times[earlier_idx] < laterTime - D)
            earlier_idx++;
        for(var i=earlier_idx; i<later_idx; i++)
            ret[0 | ((laterTime - group_times[i])/b)]++;
    }
}

// TODO: come with a better method than copy-pasting utility functions ....

var pick = function(from, indices){
    // Take elements specified by indicies from the 1d array "from".
    var result =  new from.constructor(indices.length); //make an array of the same type as the from array
    for(var i=0;i<indices.length;i++)
        result[i] = from[indices[i]];
    return result;
}

var clone_simple = function(obj){
    return JSON.parse(JSON.stringify(obj));
}

var is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b))
        return false;
    for(var aa in a) if(a.hasOwnProperty(aa))
        if(b[aa] !== a[aa])
            return false;
    for(var bb in b) if(b.hasOwnProperty(bb))
        if(b[bb] !== a[bb])
            return false;
    return true;
}
</script>

<template></template>


<script>
	"use strict";

    Polymer({
    	is:'tac-plots',
    	properties: {
			max_delta_t: {
				type: Number,
				value: 2
			},
            spike_times: {
                type: String, // taid
                value: ""
            },
			groups: {
    			type: Array,
    			value: function(){return [];},
    			notify: true
    		}
    	},
    	observers: [
    		'groups_modified(groups.*)', 
            'options_modified(max_delta_t)',
            'times_modified(spike_times)'
    	],
        attached: function(){
            var worker_builder = Polymer.DomModule.import('tac-plots','#worker');
            this.worker = worker_builder.create_for(this);
            this.worker.exec('set_max_delta_t', this.max_delta_t);
            this.taid_to_canvas = {};
            this.taid_to_rendered_options = {};
            this.taid_to_groups_idx = {};
        },
    	groups_modified: function(change){
            if(!this.worker || !change || !change.value) return;
            var taids_to_remove = [];
            var taids_to_add = [];
            var arrays = {};
            var m = window.typed_array_manager;

            if(change.path === 'groups.splices')
                change.value.indexSplices.forEach(function(s){
        			s.removed.forEach(function(group){
                        if(group.inds){
                            delete this.taid_to_canvas[group.inds];
                            delete this.taid_to_rendered_options[group.inds];
                            delete this.taid_to_groups_idx[group.inds];
                            taids_to_remove.push(group.inds);
                        }
        				if(group.tac){
    	    				m.free_canvas(group.tac);
                        }
        			}, this);

        			for(var ii=s.index, stop = s.index+s.addedCount; ii<stop; ii++){
        				var group = this.groups[ii];
                        var arr = m.get_array_clone(group.inds);
                        arrays[group.inds] = arr;
                        taids_to_add.push(group.inds);
        			}
        		}, this);

            this.worker.exec_b('update_taids', {
                add: taids_to_add,
                remove: taids_to_remove
            }, arrays);

    	},
        options_modified: function(){
            if(!this.worker) return;
            this.worker.exec('set_max_delta_t', this.max_delta_t);
        },
        times_modified: function(){
            if(this.spike_times){
                var arr = window.typed_array_manager.get_array_clone(this.spike_times);
                this.worker.exec_b('set_spike_times', {spike_times: arr});
            } else {
                if(!this.worker) return;
                this.worker.exec('set_spike_times', {});
            }
        },
        plot_hist: function(data, arrays) {
            // data.taid
            // hist = arrays[data.hist_name]
            // data.render_options
            console.log("plot_hist for: " + data.taid + "   " + JSON.stringify(data.render_options));
            console.dir(arrays[data.hist_name]);
            // TODO: actually do this properly...
            //group.tac = m.create_from_dims([128,30]);
        }

	});
</script>

  
</dom-module>