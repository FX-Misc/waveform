<!--
CUSTOM ELEMENT: tac-plots
BY: DM

This is designed to be used inside a tile-wall element.  The "groups" array of the tilewall should be bound
to this element's "groups" property.  Then whenever the tilewall's groups array is spliced this element will
be notified and can update ratemaps acordingly, with the tilewall be notified of the updates.

See cut-obj for a fairly detailed introduction to how the groups array works, and how keys are used here for
main-worker thread communication and more.  Both threads maintain a pair of maps, on the worker thread 
these maps are called:
    pkey_to_rendered_options and pkey_to_array
and on the main thread they are called:
    pkey_to_rendered_options and key_to_canvas

The worker thread independently decides which arrays need to be rendered, as new arrays arrive and settings
are changed etc.  The main thread must keep the most recently rendered version for each array (and a record
of the settings used for the render), otherwise in future it may end up wanting something which the worker
thought it had already delivered.

-->


<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="worker-builder.html">
<link rel="import" href="utils.html">
<link rel="import" href="managed-canvas.html">

<dom-module id="tac-plots">

<script is='worker-builder' id="worker" title="tac-plots" type='javascript/worker'>
"use strict";

var render_options = {
    max_delta_t: 500, // miliseconds
    n_bins: 100,
    height: 50 //px, width matches n_bins exactly
};

var spike_times;
var timebase;
var pkey_to_array = new Map(); // Note that in the worker, key's are used only for arrays of spike-indices.
var pkey_to_rendered_options = new Map(); 
var pkeys_pending_render = [];
var timer;
var pkey_generation = 0;
var show;

var set_show = function(v){
    show = v;
    // note that we don't meddle with the pkeys_pending_render list here
    // instead we use the timer to decide whether or not to bother doing any rendering
    touch_timer();
}

var set_options = function(opts){
    for(var k in render_options){
        render_options[k] = opts[k] === undefined ? render_options[k] : opts[k];
    }
    pkeys_pending_render = [];    
    if(spike_times){
        for(let pkey of pkey_to_array.keys()){
            pkeys_pending_render.push(pkey);
        }
    }
    touch_timer();
}

var set_spike_times = function(timebase_, arrays){
    timebase = timebase_;
    spike_times = arrays && arrays.data; 
    pkeys_pending_render = [];    
    if(spike_times){
        for(let pkey of pkey_to_array.keys()){
            pkeys_pending_render.push(pkey);
        }
    }
    touch_timer();
}

var update_pkeys = function(changes, arrays){

    if(changes.generation_remove !== pkey_generation)
        throw "key generation mismatch";

    // note we don't both to remove keys from the pending list
    // unless we change key generation, in which case we drop 
    // everything that's pending. This is ensures that when we
    // attempt a render we can be sure that if we do find the
    // array for the given key we know it's for the relevant 
    // generation and that it's still wanted.

    var remove_pkeys = changes.remove || [];
    for(let pkey of remove_pkeys){
        pkey_to_array.delete(pkey);
        pkey_to_rendered_options.delete(pkey);
    }

    if(changes.generation_add !== changes.generation_remove){
        pkeys_pending_render = [];
        pkey_generation = changes.generation_add;
    }

    var add_pkeys = changes.add || [];
    for(let pkey of add_pkeys){
        pkey_to_array.set(pkey, arrays[pkey]);
        pkeys_pending_render.push(pkey);
    }

    touch_timer();        
}

var touch_timer = function(){
    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from main thread to interupt
    // between ticks, we can thus cancel work as an when needed.
    if(spike_times && pkeys_pending_render.length && show === 'y')
        timer = timer || setImmediate(timer_tick);
    else
        clearImmediate(timer);
}

var timer_tick = function(){
    timer = 0;

    // find one valid thing to render...
    while(pkeys_pending_render.length > 0){
        let pkey = pkeys_pending_render.pop();
        if(pkey && pkey_to_array.get(pkey) && !is_equal_simple(pkey_to_rendered_options.get(pkey), render_options)){
            get_group_hist(pkey);
            break;
        }
    }

    touch_timer();
}

var get_group_hist = function(pkey){
    // note desired_max_delta_t and spike_times should both be in the same units
    let group_times = pick(spike_times, pkey_to_array.get(pkey));

    // build pairwise-diff histogram
    let hist = new Uint32Array(render_options.n_bins+1);
    get_group_hist_sub(hist, group_times, render_options.max_delta_t/1000*timebase, 
                        render_options.max_delta_t/1000*timebase/render_options.n_bins);
    
    hist = plot_histogram(hist, render_options.height);
    let opts = clone_simple(render_options);
    pkey_to_rendered_options.set(pkey, opts);
    exec_main_b('plot_hist', {
        pkey: pkey,
        generation: pkey_generation,
        hist_name: 'hist',
        dims: [opts.n_bins, opts.height],
        render_options: opts
    }, {hist: hist});
}

var get_group_hist_sub = function(ret, group_times, D, b){
    // For every pair of spikes separated in time by no more than time D, bin
    // up the time separation, with bin size b, and record it in hist, ret.
    for(var later_idx=1, earlier_idx=0; later_idx<group_times.length; later_idx++){
        let later_time = group_times[later_idx];
        while (group_times[earlier_idx] < later_time - D){
            earlier_idx++;
        }
        for(let i=earlier_idx; i<later_idx; i++){
            ret[0 | ((later_time - group_times[i])/b)]++;
        }
    }
}

// TODO: come with a better method than copy-pasting utility functions ....

var plot_histogram = function(vals, h){
    let w = vals.length-1;
    let max = 0;
    for(let ii=0; ii<w; ii++){
        (vals[ii] > max) && (max = vals[ii]);
    }
    let factor = h/max;
    let color_a = 0xff0000ff;
    let im = new Uint32Array(w*h);
    for(let x=0, y=vals[0]; x<w; x++){
        let target_y = 0 | (vals[x]*factor);
        for(; y<target_y; y++){
            im[w*(h-y) + x] = color_a;
        }
        for(; y>target_y; y--){
            im[w*(h-y) + x] = color_a;
        }
        im[w*(h-y) + x] = color_a;
    }
    return im;
}

var pick = function(from, indices){
    // Take elements specified by indicies from the 1d array "from".
    var result =  new from.constructor(indices.length); //make an array of the same type as the from array
    for(let i=0;i<indices.length;i++)
        result[i] = from[indices[i]];
    return result;
}

var clone_simple = function(obj){
    return JSON.parse(JSON.stringify(obj));
}

var is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(var aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
}
</script>

<template></template>


<script>
    "use strict";


    Polymer({
        is:'tac-plots',
        properties: {
               max_delta_t: {
                type: Number, // in miliseconds
                value: 2,
                notify: true
            }, spike_times: {
                type: Object, // array akey "data" and timebase Number in Hz (ie per second not per milisecond)
                value: function(){ return {};},
                notify: true
            }, show: {
                type: String, // "y" or "n" (to match other modules which have multiple toggle-able things)
                value: "y",
                notify: true
            }, groups: {
                type: Array,
                value: function(){return [];},
                notify: true,
                observer: '_groups_set'
            }
        }, observers: [
            '_groups_spliced(groups.splices)', 
            '_options_modified(max_delta_t)',
            '_times_modified(spike_times)',
            '_show_changed(show)'
        ], created: function(){
            // copy-paste defaults from worker code above (could implement
            // something  more complicated, but hey this works and is easy).
            this._options = {
                max_delta_t: 500, // miliseconds
                n_bins: 100,
                height: 50 //px, width matches n_bins exactly
            };
            var worker_builder = Polymer.DomModule.import('tac-plots','#worker');
            this._worker = worker_builder.create_for(this);
            this._pkey_generation = 0;
            this._times_is_on_worker = false;
        }, _update_okeys: function(okeys_to_remove, okeys_to_add, generation_remove, generation_add){
            var am = Utils.typed_array_manager;
            var cm = Utils.canvas_manager;

            var added_arrays = {};
            var pkeys_to_add = []; 
            if (this.show === 'y'){
                // get clones of new arrays to send to worker
                for(let okey of okeys_to_add){
                    pkeys_to_add.push(okey._pkey);
                    added_arrays[okey._pkey] = am.get_array_clone(okey.akey);
                    okey._tac_is_on_worker = true;                    
                }
            }

            // free canvases, it's our responsiblity to do this, whereas 
            // freeing the inds arrays was the responsibility of cut-obj.
            var pkeys_to_remove = [];
            for(let okey of okeys_to_remove){
                pkeys_to_remove.push(okey._pkey);
                cm.free_canvas(okey.tac);
                cm.free_canvas(okey._tac_other);
                okey.tac = null;
                okey._tac_other = null;
                okey._tac_other_options = null;
                okey._tac_is_on_worker = false;
            }

            // inform worker of the new/deleted arrays
            this._worker.exec_b('update_pkeys', {
                add: pkeys_to_add,
                remove: pkeys_to_remove,
                generation_remove: generation_remove,
                generation_add: generation_add
            }, added_arrays);

        }, _groups_set: function(new_val, old_val){
            this._groups_collection = Array.isArray(new_val) && Polymer.Collection.get(new_val);
            this._update_okeys(old_val || [], new_val || [], this._pkey_generation, ++this._pkey_generation); // added keys are for a new generation
        }, _groups_spliced: function(splices){
            let parsed = Utils.parse_splices(splices);
            this._update_okeys(parsed.removed, parsed.added, this._pkey_generation, this._pkey_generation);
        }, _options_modified: function(){
            this._options.max_delta_t = this.max_delta_t;
            this._worker.exec('set_options', this._options);

            // if we already have the right answer in any cases, then we must apply that now
            // because the worker is not going to send it again
            for(let okey of this.groups){
                if(okey.tac !== okey._tac_other && Utils.is_equal_simple(okey._tac_other_options, this._options)){
                    cm.free_canvas(okey.tac);
                    okey.tac = okey._tac_other;
                    this.notifyPath('groups.' + okey._pkey + '.tac', okey.tac); // possibly more efficient to avoid set call with array key            
                }
            }
        }, _times_modified: function(){
            if(this.show === 'y'){
                if(this.spike_times){
                    var arr = Utils.typed_array_manager.get_array_clone(this.spike_times.times);
                    this._worker.exec_b('set_spike_times', this.spike_times.timebase, {data: arr});
                } else {
                    if(!this._worker) return;
                    this._worker.exec('set_spike_times', {});
                }
                this._times_is_on_worker = true;
            } else {
                if(!this.spike_times && this._times_is_on_worker){
                    this._worker.exec('set_spike_times', {});
                }
                this._times_is_on_worker = false;
            }
        }, _show_changed: function(){
            if(this.show === 'y'){
                var added = [];
                for(let okey of this.groups)if(!okey._tac_is_on_worker){
                    added.push(okey);
                }
                this._update_okeys([], added, this._pkey_generation, this._pkey_generation);
                if(!this._times_is_on_worker){
                    this._times_modified();
                }
            } else if (this.show === 'n'){
                // nothing to do here
            } else {
                throw "invalid value for show";
            }
            if(this._worker){
                this._worker.exec('set_show', this.show); // worker needs to know even if it's all 'n', because then it won't bother doing anything.
            }
        }, plot_hist: function(data, arrays) {
            if(data.generation !== this._pkey_generation)
                return; // pft! get with the times, dude.
            let okey = this._groups_collection.getItem(data.pkey);
            let cm = Utils.canvas_manager;
            let ckey = cm.store_from_buffer(arrays.hist.buffer, data.dims);
            cm.free_canvas(okey._tac_other);
            okey._tac_other = ckey;
            okey._tac_other_options = data.render_options;
            if(Utils.is_equal_simple(data.render_options, this._options)){
                cm.free_canvas(okey.tac);
                okey.tac = ckey;
                this.notifyPath('groups.' + data.pkey + '.tac', okey.tac); // possibly more efficient to avoid set call with array key            
            }
        }

    });
</script>

  
</dom-module>