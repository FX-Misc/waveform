<!--
CUSTOM ELEMENT: tac-plots
BY: DM

This is designed to be used inside a tile-wall element.  The "groups" array of the tilewall should be bound
to this element's "groups" property.  Then whenever the tilewall's groups array is spliced this element will
be notified and can update ratemaps acordingly, with the tilewall be notified of the updates.

See cut-obj for a fairly detailed introduction to how the groups array works, and how keys are used here for
main-worker thread communication and more.  Both threads maintain a pair of maps, on the worker thread 
these maps are called:
    key_to_rendered_options and key_to_array
and on the main thread they are called:
    key_to_rendered_options and key_to_canvas

The worker thread independently decides which arrays need to be rendered, as new arrays arrive and settings
are changed etc.  The main thread must keep the most recently rendered version for each array (and a record
of the settings used for the render), otherwise in future it may end up wanting something which the worker
thought it had already delivered.

-->


<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="worker-builder.html">
<link rel="import" href="utils.html">
<link rel="import" href="managed-canvas.html">

<dom-module id="tac-plots">

<script is='worker-builder' id="worker" title="tac-plots" type='javascript/worker'>
"use strict";

var render_options = {
    max_delta_t: undefined, // miliseconds
    n_bins: 100,
    height: 50 //px, width matches n_bins exactly
};
var spike_times;
var timebase;
var key_to_array = new Map(); // Note that in the worker, key's are used only for arrays of spike-indices.
var key_to_rendered_options = new Map(); 
var keys_pending_render = [];
var timer;
var key_generation = 0;
var show;

var set_show = function(v){
    show = v;
    // note that we don't meddle with the keys_pending_render list here
    // instead we use the timer to decide whether or not to bother doing any rendering
    touch_timer();
}

var set_options = function(opts){
    for(var k in render_options){
        render_options[k] = opts[k] === undefined ? render_options[k] : opts[k];
    }
    keys_pending_render = [];    
    if(spike_times){
        for(let key in key_to_array){
            keys_pending_render.push(key);
        }
    }
    touch_timer();
}

var set_spike_times = function(timebase_, arrays){
    timebase = timebase_;
    spike_times = arrays && arrays.data; 
    keys_pending_render = [];    
    if(spike_times){
        for(let key in key_to_array){
            keys_pending_render.push(key);
        }
    }
    touch_timer();
}

var update_keys = function(changes, arrays){

    if(changes.generation_remove !== key_generation)
        throw "key generation mismatch";

    // note we don't both to remove keys from the pending list
    // unless we change key generation, in which case we drop 
    // everything that's pending. This is ensures that when we
    // attempt a render we can be sure that if we do find the
    // array for the given key we know it's for the relevant 
    // generation and that it's still wanted.

    var remove_keys = changes.remove || [];
    for(let key of remove_keys){
        key_to_array.delete(key);
        key_to_rendered_options.delete(key);
    }

    if(changes.generation_add !== changes.generation_remove){
        keys_pending_render = [];
        key_generation = changes.generation_add;
    }

    var add_keys = changes.add || [];
    for(let key of add_keys){
        key_to_array.set(key, arrays[key]);
        keys_pending_render.push(key);
    }

    touch_timer();        
}

var touch_timer = function(){
    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from main thread to interupt
    // between ticks, we can thus cancel work as an when needed.
    if(spike_times && keys_pending_render.length && show === 'y')
        timer = timer || setImmediate(timer_tick);
    else
        clearImmediate(timer);
}

var timer_tick = function(){
    timer = 0;

    // find one valid thing to render...
    while(keys_pending_render.length > 0){
        var key = keys_pending_render.pop();
        if(key && key_to_array.get(key) && !is_equal_simple(key_to_rendered_options.get(key), render_options)){
            get_group_hist(key);
            break;
        }
    }

    touch_timer();
}

var get_group_hist = function(key){
    // note desired_max_delta_t and spike_times should both be in the same units
    var group_times = pick(spike_times, key_to_array.get(key));

    // build pairwise-diff histogram
    var hist = new Uint32Array(render_options.n_bins+1);
    get_group_hist_sub(hist, group_times, render_options.max_delta_t/1000*timebase, 
                        render_options.max_delta_t/1000*timebase/render_options.n_bins);
    
    hist = plot_histogram(hist, render_options.height);
    key_to_rendered_options.set(key, clone_simple(render_options));
    exec_main_b('plot_hist', {
        key: key,
        generation: key_generation,
        hist_name: 'hist',
        dims: [render_options.n_bins, render_options.height],
        render_options: key_to_rendered_options.get(key)
    }, {hist: hist});
}

var get_group_hist_sub = function(ret, group_times, D, b){
    // For every pair of spikes separated in time by no more than time D, bin
    // up the time separation, with bin size b, and record it in hist, ret.
    for(var later_idx=1, earlier_idx=0; later_idx<group_times.length; later_idx++){
        let later_time = group_times[later_idx];
        while (group_times[earlier_idx] < later_time - D)
            earlier_idx++;
        for(let i=earlier_idx; i<later_idx; i++)
            ret[0 | ((later_time - group_times[i])/b)]++;
    }
}

// TODO: come with a better method than copy-pasting utility functions ....

var plot_histogram = function(vals, h){
    let w = vals.length-1;
    let max = 0;
    for(let ii=0; ii<w; ii++){
        (vals[ii] > max) && (max = vals[ii]);
    }
    let factor = h/max;
    let color_a = 0xff0000ff;
    let im = new Uint32Array(w*h);
    for(let x=0, y=vals[0]; x<w; x++){
        let target_y = 0 | (vals[x]*factor);
        for(; y<target_y; y++){
            im[w*(h-y) + x] = color_a;
        }
        for(; y>target_y; y--){
            im[w*(h-y) + x] = color_a;
        }
        im[w*(h-y) + x] = color_a;
    }
    return im;
}

var pick = function(from, indices){
    // Take elements specified by indicies from the 1d array "from".
    var result =  new from.constructor(indices.length); //make an array of the same type as the from array
    for(let i=0;i<indices.length;i++)
        result[i] = from[indices[i]];
    return result;
}

var clone_simple = function(obj){
    return JSON.parse(JSON.stringify(obj));
}

var is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(var aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
}
</script>

<template></template>


<script>
    "use strict";


    Polymer({
        is:'tac-plots',
        properties: {
            max_delta_t: {
                type: Number, // in miliseconds
                value: 2,
                notify: true
            },
            spike_times: {
                type: Object, // array akey "data" and timebase Number in Hz (ie per second not per milisecond)
                value: function(){ return {};},
                notify: true
            },
            show: {
                type: String, // "y" or "n" (to match other modules which have multiple toggle-able things)
                value: "y",
                notify: true
            },
            groups: {
                type: Array,
                value: function(){return [];},
                notify: true,
                observer: '_groups_set'
            }
        },
        observers: [
            '_groups_spliced(groups.splices)', 
            '_options_modified(max_delta_t)',
            '_times_modified(spike_times)',
            '_show_changed(show)'
        ],
        created: function(){
            var worker_builder = Polymer.DomModule.import('tac-plots','#worker');
            this._worker = worker_builder.create_for(this);
            this._key_to_canvas = new Map();
            this._key_to_rendered_options = new Map();
            this._key_is_on_worker = new Map();
            this._key_generation = 0;
            this._times_is_on_worker = false;
        },
        _update_keys: function(keys_to_remove, keys_to_add, generation_remove, generation_add){
            var am = Utils.typed_array_manager;
            var cm = Utils.canvas_manager;

            var added_arrays = {};
            if (this.show === 'y'){
                // get clones of new arrays to send to worker
                for(let key of keys_to_add){
                    let box = this.groups_collection.getItem(key);
                    if(box){
                        added_arrays[key] = am.get_array_clone(box.akey);
                        this._key_is_on_worker.set(key, true);                        
                    }
                }
            } else {
                // if we are not showing the plot, we don't actually get 
                // any arrays, but we need to remmeber that we never sent them
                // to the worker.
                for(let key of keys_to_add){
                    this._key_is_on_worker.set(key, false);
                }
                keys_to_add = [];
            }

            // inform worker of the new/deleted arrays
            this._worker.exec_b('update_keys', {
                add: keys_to_add,
                remove: keys_to_remove,
                generation_remove: generation_remove,
                generation_add: generation_add
            }, added_arrays);

            // free canvases, it's our responsiblity to do this, whereas 
            // freeing the inds arrays was the responsibility of cut-obj.
            for(let key of keys_to_remove){
                let canvas = this._key_to_canvas.get(key);
                if(canvas){
                    cm.free_canvas(canvas);
                }
                // TODO: the next line doesn't work because the item has already been removed from the collection at this point
                //this.groups_collection.getItem(key).tac = null; // note we don't use Polymer set as this okey is  being (temporarily) discarded
                this._key_to_canvas.delete(key);
                this._key_to_rendered_options.delete(key);
                this._key_is_on_worker.delete(key); // we can also forget this
            }
        },
        _groups_set: function(new_val, old_val){
            var removed = this.groups_collection ? 
                            this.groups_collection.getKeys() : []; 
            this.groups_collection = Array.isArray(new_val) && Polymer.Collection.get(new_val);
            var added = this.groups_collection ? 
                            this.groups_collection.getKeys() : []; 
            this._update_keys(removed, added, this._key_generation, ++this._key_generation); // added keys are for a new generation
        },
        _groups_spliced: function(splices){
            if(!splices) return;
            var dedupes = Utils.dedupe(splices.keySplices);
            this._update_keys(dedupes.removed, dedupes.added, this._key_generation, this._key_generation);
        },
        _options_modified: function(){
            this._worker.exec('set_options', {
                max_delta_t: this.max_delta_t
            });
        },
        _times_modified: function(){
            if(this.show === 'y'){
                if(this.spike_times){
                    var arr = Utils.typed_array_manager.get_array_clone(this.spike_times.times);
                    this._worker.exec_b('set_spike_times', this.spike_times.timebase, {data: arr});
                } else {
                    if(!this._worker) return;
                    this._worker.exec('set_spike_times', {});
                }
                this._times_is_on_worker = true;
            } else {
                if(!this.spike_times && this._times_is_on_worker){
                    this._worker.exec('set_spike_times', {});
                }
                this._times_is_on_worker = false;
            }
        },
        _show_changed: function(){
            if(this.show === 'y'){
                var added = [];
                for(let [k,v] in this._key_is_on_worker)if(!v){
                    added.push(k);
                }
                this._update_keys([], added, this._key_generation, this._key_generation);
                if(!this._times_is_on_worker){
                    this._times_modified();
                }
            } else if (this.show === 'n'){
                // nothing to do here
            } else {
                throw "invalid value for show";
            }
            if(this._worker){
                this._worker.exec('set_show', this.show); // worker needs to know even if it's all 'n', because then it won't bother doing anything.
            }
        },
        plot_hist: function(data, arrays) {
            if(data.generation !== this._key_generation)
                return; // pft! get with the times, dude.
            let group = this.groups_collection.getItem(data.key);
            let cm = Utils.canvas_manager;
            let ckey = cm.store_from_buffer(arrays.hist.buffer, data.dims);
            this.set('groups.' + data.key + '.tac', ckey);
            this._key_to_canvas.set(data.key, ckey);
            this._key_to_rendered_options.set(data.key, data.render_options);
        }

    });
</script>

  
</dom-module>