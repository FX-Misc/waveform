<!--
CUSTOM ELEMENT: tac-plots
BY: DM

This is designed to be used inside a tile-wall element.  The "groups" array of the tilewall should be bound
to this element's "groups" property.  Then whenever the tilewall's groups array is spliced this element will
be notified and can update ratemaps acordingly, with the tilewall be notified of the updates.

See cut-obj for a fairly detailed introduction to how the groups array works, and how keys are used here for
main-worker thread communication and more.  Both threads maintain a pair of maps, on the worker thread 
these maps are called:
    key_to_rendered_options and key_to_array
and on the main thread they are called:
    key_to_rendered_options and key_to_canvas

The worker thread independently decides which arrays need to be rendered, as new arrays arrive and settings
are changed etc.  The main thread must keep the most recently rendered version for each array (and a record
of the settings used for the render), otherwise in future it may end up wanting something which the worker
thought it had already delivered.

-->


<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="worker-builder.html">
<link rel="import" href="utils.html">
<link rel="import" href="managed-canvas.html">

<dom-module id="tac-plots">

<script is='worker-builder' id="worker" title="tac-plots" type='javascript/worker'>
"use strict";

var render_options = {
    max_delta_t: undefined,
    n_bins: 100
};
var spike_times;
var timebase;
var key_to_array = new Map(); // Note that in the worker, key's are used only for arrays of spike-indices.
var key_to_rendered_options = new Map(); 
var keys_pending_render = [];
var timer;
var key_generation = 0;
var show;

var set_show = function(v){
    show = v;
    // note that we don't meddle with the keys_pending_render list here
    // instead we use the timer to decide whether or not to bother doing any rendering
    touch_timer();
}

var set_options = function(opts){
    for(var k in render_options){
        render_options[k] = opts[k] === undefined ? render_options[k] : opts[k];
    }
    keys_pending_render = [];    
    if(spike_times){
        for(let key in key_to_array){
            keys_pending_render.push(key);
        }
    }
    touch_timer();
}

var set_spike_times = function(timebase_, arrays){
    timebase = timebase_;
    spike_times = arrays && arrays.data; 
    keys_pending_render = [];    
    if(spike_times){
        for(let key in key_to_array){
            keys_pending_render.push(key);
        }
    }
    touch_timer();
}

var update_keys = function(changes, arrays){

    if(changes.generation_remove !== key_generation)
        throw "key generation mismatch";

    // note we don't both to remove keys from the pending list
    // unless we change key generation, in which case we drop 
    // everything that's pending. This is ensures that when we
    // attempt a render we can be sure that if we do find the
    // array for the given key we know it's for the relevant 
    // generation and that it's still wanted.

    var remove_keys = changes.remove || [];
    for(var ii=0; ii<remove_keys.length; ii++){
        key_to_array.delete(remove_keys[ii]);
        key_to_rendered_options.delete(remove_keys[ii]);
    }

    if(changes.generation_add !== changes.generation_remove){
        keys_pending_render = [];
        key_generation = changes.generation_add;
    }

    var add_keys = changes.add || [];
    for(var ii=0; ii<add_keys.length; ii++){
        key_to_array[add_keys[ii]] = arrays[add_keys[ii]];
        keys_pending_render.push(add_keys[ii]);
    }

    touch_timer();        
}

var touch_timer = function(){
    // turns timer on if there's work to be done, otherwise stops it (if it was running)
    // note it's not actually a timer, because the interval is zero!
    // the point of using this is that it enables messages from main thread to interupt
    // between ticks, we can thus cancel work as an when needed.
    if(spike_times && keys_pending_render.length && show === 'y')
        timer = timer || setImmediate(timer_tick);
    else
        clearImmediate(timer);
}

var timer_tick = function(){
    timer = 0;

    // find one valid thing to render...
    while(keys_pending_render.length > 0){
        var key = keys_pending_render.pop();
        if(key && key_to_array[key] && !is_equal_simple(key_to_rendered_options[key], render_options)){
            get_group_hist(key);
            break;
        }
    }

    touch_timer();
}

var get_group_hist = function(key){
    // note desired_max_delta_t and spike_times should both be in the same units
    var group_times = pick(spike_times, key_to_array[key]);

    // build pairwise-diff histogram
    var ret = new Uint32Array(render_options.n_bins+1);
    get_group_hist_sub(ret, group_times, render_options.max_delta_t*timebase, 
                        render_options.max_delta_t*timebase/render_options.n_bins);
 
    key_to_rendered_options[key] = clone_simple(render_options);
    exec_main_b('plot_hist', {
        key: key,
        generation: key_generation,
        hist_name: 'hist',
        render_options: key_to_rendered_options[key]
    }, {hist: ret});
}

var get_group_hist_sub = function(ret, group_times, D, b){
    // For every pair of spikes separated in time by no more than time D, bin
    // up the time separation, with bin size b, and record it in hist, ret.
    for(var later_idx=1, earlier_idx=0; later_idx<group_times.length; later_idx++){
        let later_time = group_times[later_idx];
        while (group_times[earlier_idx] < later_time - D)
            earlier_idx++;
        for(let i=earlier_idx; i<later_idx; i++)
            ret[0 | ((later_time - group_times[i])/b)]++;
    }
}

// TODO: come with a better method than copy-pasting utility functions ....

var pick = function(from, indices){
    // Take elements specified by indicies from the 1d array "from".
    var result =  new from.constructor(indices.length); //make an array of the same type as the from array
    for(let i=0;i<indices.length;i++)
        result[i] = from[indices[i]];
    return result;
}

var clone_simple = function(obj){
    return JSON.parse(JSON.stringify(obj));
}

var is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(var aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
}
</script>

<template></template>


<script>
	"use strict";


    Polymer({
    	is:'tac-plots',
    	properties: {
			max_delta_t: {
				type: Number,
				value: 2
			},
            spike_times: {
                type: Object, // array akey "data" and timebase Number in same units as max_delta_t
                value: function(){ return {};}
            },
            show: {
                type: String, // "y" or "n" (to match other modules which have multiple toggle-able things)
                value: "y"
            },
			groups: {
    			type: Array,
    			value: function(){return [];},
    			notify: true
    		}
    	},
    	observers: [
    		'_groups_set(groups)',
            '_groups_spliced(groups.splices)', 
            '_options_modified(max_delta_t)',
            '_times_modified(spike_times)',
            '_show_changed(show)'
    	],
        created: function(){
            var worker_builder = Polymer.DomModule.import('tac-plots','#worker');
            this.worker = worker_builder.create_for(this);
            this.key_to_canvas = {};
            this.key_to_rendered_options = {};
            this.key_is_on_worker = {};
            this.key_generation = 0;
            this.times_is_on_worker = false;
        },
        _update_keys: function(keys_to_remove, keys_to_add, generation_remove, generation_add){
            var am = Utils.typed_array_manager;
            var cm = Utils.canvas_manager;

            var added_arrays = {};
            if (this.show === 'y'){
                // get clones of new arrays to send to worker
                for(let ii=0; ii<keys_to_add.length; ii++){
                    let key = keys_to_add[ii];
                    let akey = this.groups_collection.getItem(key).inds;
                    added_arrays[key] = am.get_array_clone(akey);
                    this.key_is_on_worker[key] = true;
                }
            } else {
                // if we are not showing the plot, we don't actually get 
                // any arrays, but we need to remmeber that we never sent them
                // to the worker.
                for(let ii=0; ii<keys_to_add.length; ii++){
                    this.key_is_on_worker[key] = false;
                }
                keys_to_add = [];
            }

            // inform worker of the new/deleted arrays
            this.worker.exec_b('update_keys', {
                add: keys_to_add,
                remove: keys_to_remove,
                generation_remove: generation_remove,
                generation_add: generation_add
            }, added_arrays);

            // free canvases, it's our responsiblity to do this, whereas 
            // freeing the inds arrays was the responsibility of cut-obj.
            for(let ii=0; ii<keys_to_remove.length; ii++){
                let key = keys_to_remove[ii];
                let canvas = this.key_to_canvas[key];
                if(canvas){
                    cm.free_canvas(canvas);
                }
                delete this.key_to_canvas[key];
                delete this.key_to_rendered_options[key];
                delete this.key_is_on_worker[key]; // we can also forget this
            }
        },
        _groups_set: function(new_val, old_val){
            var removed = this.groups_collection ? 
                            this.groups_collection.getKeys() : []; 
            this.groups_collection = Array.isArray(new_val) && Polymer.Collection.get(new_val);
            var added = this.groups_collection ? 
                            this.groups_collection.getKeys() : []; 
            this._update_keys(removed, added, this.key_generation, ++this.key_generation); // added keys are for a new generation
        },
        _groups_spliced: function(splices){
            if(!splices) return;
            var dedupes = Utils.dedupe(splices.keySplices);
            this._update_keys(dedupes.removed, dedupes.added, this.key_generation, this.key_generation);
        },
        _options_modified: function(){
            this.worker.exec('set_options', {
                max_delta_t: this.max_delta_t
            });
        },
        _times_modified: function(){
            if(this.show === 'y'){
                if(this.spike_times){
                    var arr = Utils.typed_array_manager.get_array_clone(this.spike_times.data);
                    this.worker.exec_b('set_spike_times', this.spike_times.timebase, {data: arr});
                } else {
                    if(!this.worker) return;
                    this.worker.exec('set_spike_times', {});
                }
                this.times_is_on_worker = true;
            } else {
                if(!this.spike_times && this.times_is_on_worker){
                    this.worker.exec('set_spike_times', {});
                }
                this.times_is_on_worker = false;
            }
        },
        _show_changed: function(){
            if(this.show === 'y'){
                var added = Object.keys(this.key_is_on_worker).filter(function(k){
                    return !this.key_is_on_worker[k];
                }, this);
                this._update_keys([], added, this.key_generation, this.key_generation);
                if(!this.times_is_on_worker){
                    this._times_modified();
                }
            } else if (this.show === 'n'){
                // nothing to do here
            } else {
                throw "invalid value for show";
            }
            if(this.worker){
                this.worker.exec('set_show', this.show); // worker needs to know even if it's all 'n', because then it won't bother doing anything.
            }
        },
        plot_hist: function(data, arrays) {
            if(data.generation !== this.key_generation)
                return; // pft! get with the times, dude.
            var group = this.groups_collection.getItem(data.key);
            // TODO: actually make the histogram, store it and settings locally and set on group
            //group.tac =  m.create_from_dims([128,30]);
            console.log("plot_hist for: " + data.key + "   " + JSON.stringify(data.render_options));
            console.dir(arrays[data.hist_name]);
        }

	});
</script>

  
</dom-module>