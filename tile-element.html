<!--
CUSTOM ELEMENT: tile-element 
BY: DM

The tile element is designed for use within the tilewall. The idea is to encapsulate as much of the gory DOM-ish work as possible here but
alow the main program to do all the more interesting interactivity...it's a bit of a blurred line unfortunately.

Tiles have the following attibutes:
    group_num - a number
    group_color_1, group_color_2 - colors used for the group's sticker
    group_n - number of spikes in group
    proximate/active/moving/disabled - true/false. Changes the state as described below.

And the following methods:
    updateCanvas -      the tile contains a fixed number of canvases, each of which is supposed to serve a particular purpose. Use this function to swap in new canvases.
    updateCrossHair -   specify canvasnumber and canvas (x,y) coordiantes (in css pixels not canvas pixels) or null to remove the crosshair.
    shake/clearShake - the way this works is a bit naff - it adds a shake class to the tile, but that relies on a shake keyframes being defined 
                        in the main index.html...perhaps there is a better way of doing this?
    getCanvInfo -       provide a canvas number and get canvas width/height,left top. If you also provide pageX and pageY values (found in mouse event objects) you will get back the 
                        coordinates within the canvas or null if it's outside the canvas.  TODO: actually only the more pageX/Y implementation has be written.
    getCopyOfCanvs -    provides a div containing images that are the same as the canvases.  Confusingly, when you use this for copying to the clipboard, you will get different results
                        depenedning on where you paste.  In gmail, you will get the ratemaps stretched to the size they appear in the GUI, but in google docs, it ignores the width/height 
                        attributes if only one of the two is provided, though it does honour them when both are provided. This means that the ratemaps end up not being stretched in 
                        google docs - the size of the image is dictated by the number of bins. (The waveforms have both height and width specified so they are the expected size).  That's helpful in a way
                        but rather consfusing to say the least.

There are several boolean flags that control the tile's state:
    active,moving,proximate,disabled
There are rules about how they can be combined, and more.  When all flags are false, the tile
is in null state. When another tile is moving, it cannot be active instead it is hover.

TODO: I think that most/all of the styling can be moved from js to css.
-->


<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="custom-animations.html">
<link rel="import" href="cross-hair.html">
<link rel="import" href="managed-canvas.html">
<link rel="import" href="palettes.html">

<dom-module id="tile-element">
<style>
:host {
display: inline-table;
position: relative;
transform: rotateY(0);
-webkit-transform: rotateY(0);
min-width: 98px;
min-height: 128px;
left: 0px;
top: 0px;
border: 1px solid #CCC;
line-height: 0px;
text-align: right;
}
:host(.noborder){
border: none;
}
.over{
position: absolute;
top: 0px;
left: 0px;
right: 0px;
bottom: 0px;
pointer-events: none;
}
.caption{
padding-top: 2px;
line-height: 12px;
text-align: center;
background-color:rgba(255,255,255,0.85);
box-shadow: -3px 0px 6px #ddc;
}
.sticker{
line-height: 12px;
width: 20px;
height: 17px;
border: 1px solid #000;
text-align: center;
font-size: 0.8em;
padding-top: 3px;
position: absolute;
right: 2px;
top: 2px;
z-index: 10;
}
.side{
position: absolute;
right: 0px;
top: 0px;
bottom: 0px;
width: 60px;
}
.blind{
position: absolute;
left: 0px;
right: 0px;
top: 0px;
bottom: 0px;
z-index: 100;
background: rgba(0,0,0,0.5);
display: none;
}
.dir-rm{
height:78px;
}
.speed-rm{
}
.tc{
height:50px;
}
.caption_inner{
border-bottom: 1px solid #000;
padding-bottom: 1px;
padding-top: 1px;
}
.caption_inner:last-of-type{
border-bottom: 0px;    
}
.caption_inner-label{
font-weight: bold;
font-size: 0.8em;
}
.grabber{
position: absolute;
top: 0px;
left: 0px;
right: 0px;
bottom: 0px;
}
.grabber:hover{
@apply(--grabber-hover);
}
.canvas_part_1{
display: table-cell;
vertical-align: bottom;
}
.canvas_part_2{
display: table-cell;
vertical-align: bottom;
text-align: right;    
}
.side{
display: flex;
flex-direction: column; 
}
.flex{
flex:2;
}
@-webkit-keyframes fadeout{
0%     { opacity: 1;  }
33%   { opacity: 1;   }
50%   { opacity: 0;   }
83%   { opacity: 0;   }
100%   { opacity: 1;   }
}
.placeholder{
position: absolute;
height: 100%;
width: 100%;
z-index: -1;
text-align: center;
}
.placeholder_text{
display: inline-block;
position: relative;
top: 45%;
font-size: 20px;
}
</style>

<template>
    <div class="placeholder" id="placeholder" style="display: none;">
        <div class="placeholder_text">[group [[group_num]]]</div> 
    </div>
    <div class="canvas_part_1">
        <managed-canvas ckey="[[group_model.waves]]"></managed-canvas>
        <managed-canvas ckey="[[group_model.rm_spa]]" fix_height="[[spa_rm_height]]"></managed-canvas>
    </div>
    <div class="canvas_part_2">
        <div>
            <managed-canvas ckey="[[group_model.rm_dir]]"></managed-canvas>
            <managed-canvas ckey="[[group_model.rm_speed]]"></managed-canvas>
        </div>
        <managed-canvas ckey="[[group_model.tac]]"></managed-canvas>
    </div>
    <div id='sticker' class='sticker' style$="[[_sticker_style(group_num)]]">[[group_num]]</div>
    <div id='over' class='over' style="display:none;">
        <div class='side'>
            <div class="flex"></div>
            <div class='caption'>
                <div style$='[[_show(group_model.rm_spa_max)]]' class="caption_inner">
                    [[group_model.rm_spa_max]]Hz
                    <div class="caption_inner-label">spa max</div>
                </div>
                <div style$='[[_show(group_model.rm_dir_max)]]' class="caption_inner">
                    [[group_model.rm_dir_max]]Hz
                    <div class="caption_inner-label">dir max</div>
                </div>
                <div style$='[[_show(group_model.group_mean)]]' class="caption_inner">
                    [[group_model.group_mean]]Hz
                    <div class="caption_inner-label">mean</div>
                </div>
                <div class="caption_inner">[[group_model.n_spikes]]
                    <div class="caption_inner-label">n spikes</div>
                </div>
            </div>
        </div>
    </div>
    <div id='blind' class='blind'></div>
    <div class="grabber" hidden$="{{!grabber_mode}}" on-mouseup="_grab"></div>
</template>


<script>
    "use strict";
        
    var ResetStyle = function(el){
        var display = el.style.display;
        el.style.cssText = display ? 'display:' + display : '';//if it's hidden, then keep it hidden
        el.$.over.style.cssText = 'display:none;';
        el.$.sticker.style.right = '';
        el.$.sticker.style.webkitAnimation = '';
        el.$.blind.style.cssText = '';
        el.$.placeholder.style.display = 'none';
        var canvases = Polymer.dom(el.root).querySelectorAll('managed-canvas');
        for(var ii=0; ii<canvases.length; ii++)
            canvases[ii].style.webkitAnimation = '';
        Polymer.dom.flush();
    }
    
    var StyleActive = function(el){
        ResetStyle(el);
        el.style.boxShadow = '0px 0px 5px 3px #fc0';
        el.style.backgroundColor = '#eee';
        el.$.over.style.display = '';          
    }
    
    var StyleProxiamte = function(el){
        StyleMoving(el);
        el.style.backgroundColor = '';
        //TODO: need to deal with animation prefixing
        el.style.opacity = '1';
        el.$.sticker.style.right = '26px';
        el.$.sticker.style.webkitAnimation = 'fadeout 1.5s linear infinite';
        var canvases = Polymer.dom(el.root).querySelectorAll('managed-canvas');
        for(var ii=0; ii<canvases.length; ii++)
            canvases[ii].style.webkitAnimation = 'fadeout 1.5s linear infinite';
        Polymer.dom.flush();
    }
    
    var StyleMoving = function(el){
        ResetStyle(el);
        el.style.opacity = '0.5';
        el.style.borderWidth = '10px';
        el.style.margin = '-9px';
        el.style.borderColor = '#000';
        el.style.backgroundColor = '#888';
        el.style.pointerEvents = 'none';
        el.style.zIndex = '100';
        el.$.placeholder.style.display = '';
    }
    
    var StyleDisabled = function(el){
        ResetStyle(el);
        el.$.blind.style.display = 'block';
        el.style.pointerEvents = 'none';
    }

    Polymer({
        is:'tile-element',
        behaviors: [
            Polymer.NeonAnimationRunnerBehavior
        ], properties: {
            group_num: {
                type: Number,
                notify: true,
                value: -1,
                notify: true
            },
            group_model: {
                type: Object,
                notify: true,
                value: function(){return {};},
                notify: true
            },
            moving: {
                type: Boolean,
                value: false,
                notify: true
            },
            active: {
                type: Boolean,
                value: false,
                notify: true
            },
            proximate: {
                type: Boolean,
                value: false,
                notify: true
            },
            disabled: {
                type: Boolean,
                value: false,
                notify: true
            },
            spa_rm_height:{
                type: Number,
                value: 120,
                notify: true
            },
            animationConfig: { // for use with NeonAnimationRunnerBehavior
                value: function(){
                    return { shake: {name: 'shake-animation', node: this} };
                }
            },
            grabber_mode: {
                type: Boolean,
                value: false,
                notify: true
            }
        },
        observers: [
            '_update_state(active, moving, proximate, disabled)'
        ], _show: function(val){ // for use in binding as style$='display:_show(val)', truthy vals are shown, falsey are hidden
            return val !== null && val !== "" && val >= 0 ? '' : 'display:none;';
        }, update_cross_hair: function(canvasNum,x,y){
            /* specify the x and y coordinates of the cross hair in canvas (css not pixel) coordinates.
                if x is null/undefined, any existing crosshair will be removed.     */
            var canv = Polymer.dom(this.root).querySelectorAll('canvas')[canvasNum];
            var xh = canv.nextElementSibling
            xh = xh && xh.tagName.toLowerCase() == "cross-hair" ? xh : null; //xh must be the cross-hair following the requested canvas or null if there isnt one
            
            if (xh && !(x==0 || x>0)){
                xh.remove();
            }else{
                if(!xh){
                    xh = document.createElement('cross-hair');
                    xh.w = parseInt(getComputedStyle(canv).width);
                    xh.setLeftTop(canv.offsetLeft,canv.offsetTop);
                    Polymer.dom(canv.parentNode).insertBefore(xh, canv.nextElementSibling)//insert after the canvas
                }
                xh.setXY(x,y);
            }
        }, _sticker_style: function(group_num){
            return "background-color:" + Palettes.flag_css[group_num] + "; color:" + Palettes.flag_css_text[group_num] + ";";
        }, _update_state: function(active, moving, proximate, disabled){
            // TODO: this can all be converted to css classes now I think
            if(disabled){
                if(moving)
                    throw "cannot disable tile while moving";
                this.set('active', false); // may have been true
                StyleDisabled(this);
            } else if(moving){
                if(proximate){
                    StyleProxiamte(this);
                }else{
                    StyleMoving(this);
                }
            } else if(active){
                StyleActive(this);
            } else {
                ResetStyle(this);
            }

            if(proximate && !moving)
                console.warn("tile for group " + this.group_num + " cannot be proximate unless it is moving");
        }, shake: function(){
            this.cancelAnimation();
            this.playAnimation('shake');
        }, translate_xy: function(x,y){
            if(x || y){
                this.transform('translate(' + x + 'px,' + y + 'px)');
                this.transform('translate(' + -x + 'px,' + -y + 'px)', this.$.placeholder)
            } else {
                this.transform('');
                this.transform('',this.$.placeholder);
            }
        }, _grab: function(){
            let rect = this.getBoundingClientRect();
            this.fire('grab_group', {
                src_client_x: rect.left,
                src_client_y: rect.top,
                group: this.group_model
            });
        }
    });
</script>

  
</dom-module>