<link rel="import" href="patch_polymer.html">

<script>

var Utils = {}

Utils.parse_splices = function(splices, give_moved){
    // I really don't understand what you get from an array.splices observer.
    // Here we takes the "splices" object provided, and guarantee to return
    // an object with two arrays of items called added and removed.
    // if give_moodified is truthy, then we provide a third array, modified
    // giving an array of objects which had their index changed

    var added_keys, removed_keys, moved_keys;

    // Firstly, get the list of added and removed *keys*
    if(!splices || !splices.keySplices || splices.keySplices.length === 0){
        // nothing
        added_keys = [];
        removed_keys = [];
    } else if (splices.keySplices.length === 1){
        // assume that if there's only one element in the array then it's already properly de-deduped
        added_keys = splices.keySplices[0].added;
        removed_keys = splices.keySplices[0].removed;
    } else {
        // multiple splices..I'm not sure how to interpret the indexSplices,
        // but the keySplices is easier.
        added_keys = new Set(), removed_keys = new Set();
        for (let s of splices.keySplices) {
            for (let key of s.removed) {
                if(added_keys.has(key)){
                    added_keys.delete(key);
                } else {
                    removed_keys.add(key);
                }
            }
            for (let key of s.added) {
                if(removed_keys.has(key)){
                    removed_keys.delete(key);
                } else {
                    added_keys.add(key);
                }
            }
        }
    }

   
    // Now convert the keys to objects...
    var added = [], removed = [], moved = [];

    if(added_keys.length || added_keys.size){
        let coll = Polymer.Collection.get(splices.indexSplices[0].object);
        for(let key of added_keys){
            let item = coll.getItem(key);
            (item !== undefined) && added.push(item);
        }        
    }

    if(removed.length || removed.size){
        // we can't use getItem for removed items, because they're no longer in the
        // collection.

        // note that this bit depends on the polymer patch which sets _pkey
        let discarded_items = new Map();
        for(let s of splices.indexSplices){
            for(let item of s.removed){
                discarded_items.set(item._pkey, item);  
            }
        }
        for(let key of removed_keys){
            let item = discarded_items.get(key);
            (item !== undefined) && removed.push(item);
        }
    }

    if(give_moved){
        console.warn("parse_splices give_moved=true not implemented yet.");
        moved = [];
    }

    return {
        added: added,
        removed: removed,
        moved: moved
    };


}



// simplel clone is for when there's nothing complicated to think about
Utils.simple_clone = function(a){
    var b = {};
    for(aa in a){
        b[aa] = a[aa];
    }
    return b;
};


Utils.get_key = function(arr, item){
    // don't use this in a tight loop..lift the get(arr) out of the loop.
    return Polymer.Collection.get(arr).getKey(item); 
}

Utils.is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(let aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
};

//Escape a user specified string for use in regex search.
// Taken from http://stackoverflow.com/a/3561711
Utils.regex_escape= function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};


//Takes an Array of strings and returns a regex which can be used for finding items in the set given in the list
// with the longest possible match returned. e.g.
// regex_from_list(["hello","world","hello world"]).exec("this hello world life") will match on "hello world".
Utils.regex_from_list = function(a){
    if(!a.length)
        return null;
    return RegExp(a.sort(function(a,b){
                                    return b.length-a.length;
                             }).map(Utils.regex_escape).join("|"));
};


// setImmediate (on main thread), but we just the same impementation as worker-builder
// taken/adapted from https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js
(function(){
    // exports window.setImmediate and window.clearImmediate
    var last_task_h=0;
    var tasks = {};
    window._immediate_channel = new MessageChannel();
    _immediate_channel.port1.onmessage = function(e) {
        var h = e.data;
        try {
            tasks[h] && tasks[h]();
        } finally {
            clearImmediate(h);
        }
    }
    window.setImmediate = function(cb) {
        tasks[++last_task_h] = cb;
        _immediate_channel.port2.postMessage(last_task_h);
        return last_task_h;
    }
    window.clearImmediate = function(h){
        delete tasks[h];
    }
})();



Utils.typed_array_manager = (function(){
    // This is a thin wrapper around a map

    var store = new Map();
    var last_akey = 0;
    var suffix = " (ta-manager)"; // can drop suffix using parseInt
    var validate_akey = function(akey){
        if((akey + "").indexOf(suffix) === -1)
            throw "typed-array-manager was passed invalid akey";
        return true;
    }

    return {
        store_array: function(arr){
            store.set(++last_akey, arr);
            return last_akey + suffix;
        },
        get_array: function(akey){
            if(!akey) return
            return validate_akey(akey) && store.get(parseInt(akey));
        },
        get_array_clone: function(akey){
            // note that the clone is not put in the store. It is
            // inteded to be used when dealing with workers, and needing to 
            // transfer an array in its intereity to another thread.
            if(!akey) return
            var a = this.get_array(akey);
            return a && new a.constructor(a);
        },
        free_array: function(akey){
            validate_akey(akey);
            store.delete(parseInt(akey));
        }
    };

})();


Utils.file_manager = (function(){
    // This is a thin wrapper around an array, note that you can never remove files once added
    // Note also that we actually store more than just files in the array, we also store cut "stack" objects
    var store = [undefined];
    
    return {
        store_file: function(file){
            store.push(file);
            return store.length -1;
        },
        get_file: function(fkey){
            if(!fkey) return
            return store[fkey];
        }
    };

})();



Utils.canvas_manager = (function(){
    // This is a little bit more than a thin wrapper around a Map

    var store = new Map(); // store of canvas els
    var last_ckey = 0;
    var suffix = " (canvas-manager)"; // can drop suffix using parseInt
    var validate_id = function(id){
        if((id + "").indexOf(suffix) === -1)
            throw "canvas-manager was passed invalid id";
        return true;
    }

   return {
        store_from_buffer: function(buffer, dims){
            var el = document.createElement("canvas");
            el.width = dims[0];
            el.height = dims[1];
            var ctx = el.getContext('2d');

            var im_data = ctx.createImageData(dims[0], dims[1]);
            im_data.data.set(new Uint8ClampedArray(buffer));
            ctx.putImageData(im_data, 0, 0);
            store.set(++last_ckey, el);
            return last_ckey + suffix;
        },
        store_from_dims: function(dims){
            var el = document.createElement("canvas");
            el.width = dims[0];
            el.height = dims[1];
            store.set(++last_ckey, el);
            return last_ckey + suffix;
        },
        store_canvas: function(c){
            store.set(++last_ckey, c);
            return last_ckey + suffix;
        },
        get_canvas: function(id){
            return id && validate_id(id) && store.get(parseInt(id));
        },
        get_2d_ctx: function(id){
            return validate_id(id) && store.get(parseInt(id)).getContext('2d');
        },
        free_canvas: function(id){
            id && validate_id(id);
            store.delete(parseInt(id));
        }
    };

})();
</script>