<link rel="import" href="patch-polymer.html">

<script>

var Utils = {}

Utils.parse_splices = function(splices, give_moved){
    // I really don't understand what you get from an array.splices observer.
    // Here we takes the "splices" object provided, and guarantee to return
    // an object with two arrays of items called added and removed.
    // if give_moodified is truthy, then we provide a third array, modified
    // giving an array of objects which had their index changed

    var added_keys, removed_keys, moved_keys;

    // Firstly, get the list of added and removed *keys*
    if(!splices || !splices.keySplices || splices.keySplices.length === 0){
        // nothing
        added_keys = [];
        removed_keys = [];
    } else if (splices.keySplices.length === 1){
        // assume that if there's only one element in the array then it's already properly de-deduped
        added_keys = splices.keySplices[0].added;
        removed_keys = splices.keySplices[0].removed;
    } else {
        // multiple splices..I'm not sure how to interpret the indexSplices,
        // but the keySplices is easier.
        added_keys = new Set(), removed_keys = new Set();
        for (let s of splices.keySplices) {
            for (let key of s.removed) {
                if(added_keys.has(key)){
                    added_keys.delete(key);
                } else {
                    removed_keys.add(key);
                }
            }
            for (let key of s.added) {
                if(removed_keys.has(key)){
                    removed_keys.delete(key);
                } else {
                    added_keys.add(key);
                }
            }
        }
    }

   
    // Now convert the keys to objects...
    var added = [], removed = [], moved = [];

    if(added_keys.length || added_keys.size){
        let coll = Polymer.Collection.get(splices.indexSplices[0].object);
        for(let key of added_keys){
            let item = coll.getItem(key);
            (item !== undefined) && added.push(item);
        }        
    }

    if(removed_keys.length || removed_keys.size){
        // we can't use getItem for removed items, because they're no longer in the
        // collection.

        // note that this bit depends on the polymer patch which sets _pkey
        let discarded_items = new Map();
        for(let s of splices.indexSplices){
            for(let item of s.removed)if(item){
                discarded_items.set(item._pkey, item);  
            }
        }
        for(let key of removed_keys){
            let item = discarded_items.get(key);
            (item !== undefined) && removed.push(item);
        }
    }

    if(give_moved){
        console.warn("parse_splices give_moved=true not implemented yet.");
        moved = [];
    }

    return {
        added: added,
        removed: removed,
        moved: moved
    };


}



// simplel clone is for when there's nothing complicated to think about
Utils.simple_clone = function(a){
    var b = {};
    for(aa in a){
        b[aa] = a[aa];
    }
    return b;
};


Utils.deep_clone = function(obj){
    // this doesn't bother realing with self-referential things, but it
    // does tolerate things that wouldn't work with JSON.parse(JSON.stringify)
    // in particular typed arrays (which are *not* cloned, but end up in both
    // src and dest), files, and dom elements likewise.

    if (!obj) {
        return obj;
    } else if(obj.constructor === Object || obj.constructor === Array){
        let dest = new obj.constructor();
        for(let key in obj)if(Object.hasOwnProperty.call(obj, key)){
            dest[key] = Utils.deep_clone(obj[key]);
        }
        return dest;
    } else {
        return obj; // string, numbers, and other strange things
    }


}

Utils.get_key = function(arr, item){
    // don't use this in a tight loop..lift the get(arr) out of the loop.
    return Polymer.Collection.get(arr).getKey(item); 
}

Utils.is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(let aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(let bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
};

//Escape a user specified string for use in regex search.
// Taken from http://stackoverflow.com/a/3561711
Utils.regex_escape= function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};


//Takes an Array of strings and returns a regex which can be used for finding items in the set given in the list
// with the longest possible match returned. e.g.
// regex_from_list(["hello","world","hello world"]).exec("this hello world life") will match on "hello world".
Utils.regex_from_list = function(a){
    if(!a.length)
        return null;
    return RegExp(a.sort(function(a,b){
                                    return b.length-a.length;
                             }).map(Utils.regex_escape).join("|"));
};


// setImmediate (on main thread), but we just the same impementation as worker-builder
// taken/adapted from https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js
(function(){
    // exports window.setImmediate and window.clearImmediate
    var last_task_h=0;
    var tasks = {};
    window._immediate_channel = new MessageChannel();
    _immediate_channel.port1.onmessage = function(e) {
        var h = e.data;
        try {
            tasks[h] && tasks[h]();
        } finally {
            clearImmediate(h);
        }
    }
    window.setImmediate = function(cb) {
        tasks[++last_task_h] = cb;
        _immediate_channel.port2.postMessage(last_task_h);
        return last_task_h;
    }
    window.clearImmediate = function(h){
        delete tasks[h];
    }
})();



Utils.typed_array_manager = (function(){
    // This is a thin wrapper around a map

    var store = new Map();
    var last_akey = 0;
    var suffix = " (ta-manager)"; // can drop suffix using parseInt
    var validate_akey = function(akey){
        if((akey + "").indexOf(suffix) === -1)
            throw "typed-array-manager was passed invalid akey";
        return true;
    }

    return {
        store_array: function(arr){
            store.set(++last_akey, arr);
            return last_akey + suffix;
        },
        get_array: function(akey){
            if(!akey) return
            return validate_akey(akey) && store.get(parseInt(akey));
        },
        get_array_clone: function(akey){
            // note that the clone is not put in the store. It is
            // inteded to be used when dealing with workers, and needing to 
            // transfer an array in its intereity to another thread.
            if(!akey) return
            var a = this.get_array(akey);
            return a && new a.constructor(a);
        },
        free_array: function(akey){
            validate_akey(akey);
            store.delete(parseInt(akey));
        }
    };

})();


Utils.file_manager = (function(){
    let counter = 0;
    return {
        to_fkey: function(file){
            return {
                file: file,
                id: ++counter // useful when disscussing things with workers
            };
        },
    };

})();



Utils.canvas_manager = (function(){
    
   return {
        buffer_to_ckey: function(buffer, dims){
            var el = document.createElement("canvas");
            el.width = dims[0];
            el.height = dims[1];
            var ctx = el.getContext('2d');

            var im_data = ctx.createImageData(dims[0], dims[1]);
            im_data.data.set(new Uint8ClampedArray(buffer));
            ctx.putImageData(im_data, 0, 0);
            return {canvas: el};
        },
        dims_to_ckey: function(dims){
            var el = document.createElement("canvas");
            el.width = dims[0];
            el.height = dims[1];
            return {canvas: el};
        },
        to_ckey: function(c){
            return {canvas: c};
        },
        clone_ckey: function(ckey){
            // if we were really sensible this may never be needed...but we're not
            let old_canv = ckey && ckey.canvas;
            if(!old_canv){
                return;
            }
            let new_canv = document.createElement("canvas");
            new_canv.width = old_canv.width;
            new_canv.height = old_canv.height;
            new_canv.getContext('2d').drawImage(old_canv, 0, 0);
            return {canvas: new_canv};
        },
        get_2d_ctx: function(ckey){
            return ckey && ckey.canvas && ckey.canvas.getContext('2d');
        },
        update_from_buffer: function(ckey, buffer){
            let el = ckey && ckey.canvas;
            let ctx = el.getContext('2d');
            var im_data = ctx.createImageData(el.width, el.height);
            im_data.data.set(new Uint8ClampedArray(buffer));
            ctx.putImageData(im_data, 0, 0);
        }
    };

})();
</script>