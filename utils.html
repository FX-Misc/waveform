<script>

var Utils = {}

Utils.dedupe = function(splices){
    /* takes an array the form: 
       [{added: ['a','b','c','d'], removed: ['e','f','g]}, 
        {added: ...} , ...]
     and "dedupes" it to a single pair of added and removed arrays,
     such that any items which were added and removed multiple times
     end up in the correct one of the two lists (or are ommited entirely).

     Taken/adapted from dom-repeat._applySplicesUserSort.
    */
    if (splices.length === 1){
        // assume that if there's only one element in the array then it's already properly de-deduped
        return splices[0]; 
    } else if(splices.length === 0){
        return {added: [], removed: []}; // TODO: check if this can happen
    }

    var key_map = {}; // -1: removed; +1: added; 0: neither added nor removed
    var key;

    for (var i=0, s; (i<splices.length) && (s=splices[i]); i++) {
        for (var j=0; j<s.removed.length; j++) {
            key = s.removed[j];
            key_map[key] = key_map[key] ? 0 : -1;
        }
        for (j=0; j<s.added.length; j++) {
            key = s.added[j];
            key_map[key] = key_map[key] ? 0 : 1;
        }
    }

    var removed = [];
    var added = [];
    for(key in key_map){
        if(key_map[key] == -1){
            removed.push(key);
        }else if(key_map[key] == +1){
            added.push(key);
        }
    }

    return {
        removed: removed,
        added: added
    };
    
};

Utils.simple_clone = function(a){
    var b = {};
    for(aa in a){
        b[aa] = a[aa];
    }
    return b;
};

Utils.is_equal_simple = function(a, b){
    // very simple....
    if((a && !b) || (!a && b)){
        return false;
    }
    for(var aa in a){
        if(b[aa] !== a[aa]){
            return false;
        }
    }
    for(var bb in b){
        if(b[bb] !== a[bb]){
            return false;
        }
    }
    return true;
};

//Escape a user specified string for use in regex search.
// Taken from http://stackoverflow.com/a/3561711
Utils.regex_escape= function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};


//Takes an Array of strings and returns a regex which can be used for finding items in the set given in the list
// with the longest possible match returned. e.g.
// regex_from_list(["hello","world","hello world"]).exec("this hello world life") will match on "hello world".
Utils.regex_from_list = function(a){
    if(!a.length)
        return null;
    return RegExp(a.sort(function(a,b){
                                    return b.length-a.length;
                             }).map(Utils.regex_escape).join("|"));
};


// setImmediate (on main thread), but we just the same impementation as worker-builder
// taken/adapted from https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js
(function(){
    // exports window.setImmediate and window.clearImmediate
    var last_task_h=0;
    var tasks = {};
    window._immediate_channel = new MessageChannel();
    _immediate_channel.port1.onmessage = function(e) {
        var h = e.data;
        try {
            tasks[h] && tasks[h]();
        } finally {
            clearImmediate(h);
        }
    }
    window.setImmediate = function(cb) {
        tasks[++last_task_h] = cb;
        _immediate_channel.port2.postMessage(last_task_h);
        return last_task_h;
    }
    window.clearImmediate = function(h){
        delete tasks[h];
    }
})();



Utils.typed_array_manager = (function(){
    // This is a thin wrapper around a map

    var store = new Map();
    var last_akey = 0;
    var suffix = " (ta-manager)"; // can drop suffix using parseInt
    var validate_akey = function(akey){
        if((akey + "").indexOf(suffix) === -1)
            throw "typed-array-manager was passed invalid akey";
        return true;
    }

    return {
        store_array: function(arr){
            store.set(++last_akey, arr);
            return last_akey + suffix;
        },
        get_array: function(akey){
            if(!akey) return
            return validate_akey(akey) && store.get(parseInt(akey));
        },
        get_array_clone: function(akey){
            // note that the clone is not put in the store. It is
            // inteded to be used when dealing with workers, and needing to 
            // transfer an array in its intereity to another thread.
            if(!akey) return
            var a = this.get_array(akey);
            return a && new a.constructor(a);
        },
        free_array: function(akey){
            validate_akey(akey);
            store.delete(parseInt(akey));
        }
    };

})();


Utils.file_manager = (function(){
    // This is a thin wrapper around an array, note that you can never remove files once added
    var store = [undefined];
    
    return {
        store_file: function(file){
            store.push(file);
            return store.length -1;
        },
        get_file: function(fkey){
            if(!fkey) return
            return store[fkey];
        }
    };

})();



Utils.canvas_manager = (function(){
    // This is a little bit more than a thin wrapper around a Map

    var store = new Map(); // store of canvas els
    var last_ckey = 0;
    var suffix = " (canvas-manager)"; // can drop suffix using parseInt
    var validate_id = function(id){
        if((id + "").indexOf(suffix) === -1)
            throw "canvas-manager was passed invalid id";
        return true;
    }

   return {
        store_from_buffer: function(buffer, dims){
            var el = document.createElement("canvas");
            el.width = dims[0];
            el.height = dims[1];
            var ctx = el.getContext('2d');

            var im_data = ctx.createImageData(dims[0], dims[1]);
            im_data.data.set(new Uint8ClampedArray(buffer));
            ctx.putImageData(im_data, 0, 0);
            store.set(++last_ckey, el);
            return last_ckey + suffix;
        },
        store_from_dims: function(dims){
            var el = document.createElement("canvas");
            el.width = dims[0];
            el.height = dims[1];
            store.set(++last_ckey, el);
            return last_ckey + suffix;
        },
        get_canvas: function(id){
            return validate_id(id) && store.get(parseInt(id));
        },
        get_2d_ctx: function(id){
            return validate_id(id) && store.get(parseInt(id)).getContext('2d');
        },
        free_canvas: function(id){
            validate_id(id);
            store.delete(parseInt(id));
        }
    };

})();
</script>